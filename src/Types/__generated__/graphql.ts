/* eslint-disable */
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** The `AddressEVM` custom scalar type represents EVM-based address format. */
  AddressEVM: any;
  /** The `CID` custom scalar type represents IPFS CID. */
  CID: any;
  /** The `ChainID` custom scalar type represents Chain ID. Default to be ETH mainnet. */
  ChainID: any;
  /** The `ContractAddressEVM` custom scalar type represents EVM-based address format. */
  ContractAddressEVM: any;
  /** The `Cursor` type follows relay.dev spec. */
  Cursor: any;
  /** The `DateTime` as string. Type represents date and time as the ISO Date string. */
  DateTime: any;
  /** The `EssenceID` custom scalar type represents Essence ID generated by contract. */
  EssenceID: any;
  /** The `ProfileID` custom scalar type represents Profile ID generated by contract. */
  ProfileID: any;
  /** The `Timestamp` custom scalar type represents 10-digit timestamp, e.g. 1661325789 */
  Timestamp: any;
  /** The `TokenID` custom scalar type represents Token ID generated by contract. */
  TokenID: any;
  /** The `URL` custom scalar type represents URL links. */
  URL: any;
};

export type AckVoteRequest = {
  collectId: Scalars['String'];
  txHash: Scalars['String'];
};

export type AckVoteResponse = {
  __typename?: 'AckVoteResponse';
  status: AckVoteResponse_Status;
};

export enum AckVoteResponse_Status {
  NotLogin = 'NOT_LOGIN',
  Success = 'SUCCESS'
}

/** The `Address` type provides an address information on multiple EVM chains. */
export type Address = {
  __typename?: 'Address';
  /** `address` the address. */
  address: Scalars['AddressEVM'];
  /** `chainID` the ChainID. */
  chainID: Scalars['ChainID'];
  /** `dislikeCount` the number of the  user's dislikes */
  dislikeCount: Scalars['Int'];
  /** `dislikes` the posts disliked by this address. */
  dislikes: ContentConnection;
  /** `followingCount` returns stats about a user's followings */
  followingCount: Scalars['Int'];
  /** `followings` provides a paginated list of ordered followings profiles. */
  followings: FollowConnection;
  /** `likeCount` the number of the user's likes */
  likeCount: Scalars['Int'];
  /** `likes` the posts liked by this address. */
  likes: ContentConnection;
  /** `wallet` the wallet address on Ethereum. */
  wallet?: Maybe<Wallet>;
};


/** The `Address` type provides an address information on multiple EVM chains. */
export type AddressDislikeCountArgs = {
  contentType: ContentType;
};


/** The `Address` type provides an address information on multiple EVM chains. */
export type AddressDislikesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  contentType: ContentType;
  first?: InputMaybe<Scalars['Int']>;
};


/** The `Address` type provides an address information on multiple EVM chains. */
export type AddressFollowingsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** The `Address` type provides an address information on multiple EVM chains. */
export type AddressLikeCountArgs = {
  contentType: ContentType;
};


/** The `Address` type provides an address information on multiple EVM chains. */
export type AddressLikesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  contentType: ContentType;
  first?: InputMaybe<Scalars['Int']>;
};

/** Field indicating how you would like it to be displayed */
export type Attribute = {
  __typename?: 'Attribute';
  /** `display_type` optional if the trait_type is string */
  display_type?: Maybe<Scalars['String']>;
  /** Name of the trait */
  trait_type: Scalars['String'];
  /** Value of the trait */
  value: Scalars['String'];
};

/** Field indicating how you would like it to be displayed */
export type AttributeInput = {
  /** `display_type` optional if the trait_type is string */
  display_type?: InputMaybe<Scalars['String']>;
  /** Name of the trait */
  trait_type?: InputMaybe<Scalars['String']>;
  /** Value of the trait */
  value?: InputMaybe<Scalars['String']>;
};

/** The `AvatarType` enum type provides the profile avatar type. */
export enum AvatarType {
  /** `GENERAL` a standard image. */
  General = 'GENERAL',
  /** `NFT` an NFT image. */
  Nft = 'NFT'
}

/** The `BlockchainTime` type provides block information. */
export type BlockchainTime = {
  __typename?: 'BlockchainTime';
  /** `blockNumber` the last synced block number. */
  blockNumber: Scalars['Int'];
  /** `blocksBehind` the number of blocks behind the latest block. */
  blocksBehind: Scalars['Int'];
};

/** The `CancelLikeRequest` input type specifies the params required to cancel a like or dislike. */
export type CancelLikeRequest = {
  /** `address` the user's address. */
  address: Scalars['AddressEVM'];
  /** `contentID` the content's id the user wants to cancel a like or dislike. */
  contentID: Scalars['String'];
  /** `message` the JSON-formatted string operation message to sign. */
  message: Scalars['String'];
  /** `signature` the signature from signing the `message`. */
  signature: Scalars['String'];
  /** `signingKey` the registered signing key. */
  signingKey: Scalars['String'];
};

/** The `CancelLikeResponse` type specifies the response of canceling a like or dislike. */
export type CancelLikeResponse = {
  __typename?: 'CancelLikeResponse';
  status: CancelLikeResponse_Status;
  /** `tsInServer` the server generates the timestamp for cases where the timestamp on the client-side is not reliable. */
  tsInServer?: Maybe<Scalars['Timestamp']>;
};

export enum CancelLikeResponse_Status {
  AlreadyDone = 'ALREADY_DONE',
  ExpiredSigningKey = 'EXPIRED_SIGNING_KEY',
  InvalidMessage = 'INVALID_MESSAGE',
  InvalidParams = 'INVALID_PARAMS',
  InvalidSignature = 'INVALID_SIGNATURE',
  MessageExpired = 'MESSAGE_EXPIRED',
  RateLimited = 'RATE_LIMITED',
  Success = 'SUCCESS',
  TargetNotFound = 'TARGET_NOT_FOUND'
}

export type ClaimCyberProfileWithPromoCodeInput = {
  /** `avatar` avatar URL of the profile. */
  avatar: Scalars['String'];
  /** `handle` the handle of the profile. */
  handle: Scalars['String'];
  /** `metadata` metadata URL or IPFS CID of the profile. */
  metadata: Scalars['String'];
  /** `promoCode` the promo code used to mint profile. */
  promoCode: Scalars['String'];
};

export type ClaimCyberProfileWithPromoCodeResult = {
  __typename?: 'ClaimCyberProfileWithPromoCodeResult';
  /** `status` the result of the claim profile. */
  status: ClaimCyberProfileWithPromoCodeResult_Status;
  /** `txHash` the transaction hash of the mint transaction. */
  txHash?: Maybe<Scalars['String']>;
};

export enum ClaimCyberProfileWithPromoCodeResult_Status {
  /** `ALREADY_CLAIMED` the user has already claimed profile. */
  AlreadyClaimed = 'ALREADY_CLAIMED',
  /** `BLOCKCHAIN_CALL_FAILED` the blockchain call failed. Usually because of blockchain network issue. */
  BlockchainCallFailed = 'BLOCKCHAIN_CALL_FAILED',
  /** `CLAIMING_OTHER_HANDLE` the user is claiming another handle, should wait for the handle to be unlocked if the user wants to claim a new handle. */
  ClaimingOtherHandle = 'CLAIMING_OTHER_HANDLE',
  /** `CLAIM_IN_PROGRESS_BY_OTHER` the handle is being claimed by another user. */
  ClaimInProgressByOther = 'CLAIM_IN_PROGRESS_BY_OTHER',
  /** `INVALID_CHAIN_ID` the chain ID is invalid or not supported. */
  InvalidChainId = 'INVALID_CHAIN_ID',
  /** `INVALID_HANDLE_FORMAT` the handle format is invalid. */
  InvalidHandleFormat = 'INVALID_HANDLE_FORMAT',
  /** `INVALID_PROMO_CODE` the promo code is invalid. */
  InvalidPromoCode = 'INVALID_PROMO_CODE',
  /** `NOT_LOGIN` the user is not logged in. */
  NotLogin = 'NOT_LOGIN',
  /** `REGISTERED_HANDLE` the handle is already registered. */
  RegisteredHandle = 'REGISTERED_HANDLE',
  /** `RESERVED_HANDLE` the handle is reserved. */
  ReservedHandle = 'RESERVED_HANDLE',
  /** `SUCCESS` the profile is claimed successfully. */
  Success = 'SUCCESS',
  /** `TRY_AGAIN_LATER` network is busy, try again later. */
  TryAgainLater = 'TRY_AGAIN_LATER'
}

export type ClaimCyberProfileWithTwitterInput = {
  /** `handle` the handle of the profile. */
  handle: Scalars['String'];
  /** `metadata` metadata URL or IPFS CID of the profile. */
  metadata: Scalars['String'];
};

export type ClaimCyberProfileWithTwitterResult = {
  __typename?: 'ClaimCyberProfileWithTwitterResult';
  /** `status` the result of the claim profile. */
  status: ClaimCyberProfileWithTwitterResult_Status;
  /** `txHash` the transaction hash of the mint transaction. */
  txHash?: Maybe<Scalars['String']>;
};

export enum ClaimCyberProfileWithTwitterResult_Status {
  /** `ALREADY_CLAIMED` the user has already claimed profile. */
  AlreadyClaimed = 'ALREADY_CLAIMED',
  /** `BLOCKCHAIN_CALL_FAILED` the blockchain call failed. Usually because of blockchain network issue. */
  BlockchainCallFailed = 'BLOCKCHAIN_CALL_FAILED',
  /** `CLAIMING_OTHER_HANDLE` the user is claiming another handle, should wait for the handle to be unlocked if the user wants to claim a new handle. */
  ClaimingOtherHandle = 'CLAIMING_OTHER_HANDLE',
  /** `CLAIM_IN_PROGRESS_BY_OTHER` the handle is being claimed by another user. */
  ClaimInProgressByOther = 'CLAIM_IN_PROGRESS_BY_OTHER',
  /** `INVALID_HANDLE_FORMAT` the handle format is invalid. */
  InvalidHandleFormat = 'INVALID_HANDLE_FORMAT',
  /** `NOT_ELIGIBLE` the user is not eligible to claim profile. */
  NotEligible = 'NOT_ELIGIBLE',
  /** `NOT_LOGIN` the user is not logged in. */
  NotLogin = 'NOT_LOGIN',
  /** `REGISTERED_HANDLE` the handle is already registered. */
  RegisteredHandle = 'REGISTERED_HANDLE',
  /** `RESERVED_HANDLE` the handle is reserved. */
  ReservedHandle = 'RESERVED_HANDLE',
  /** `SUCCESS` the profile is claimed successfully. */
  Success = 'SUCCESS',
  /** `TRY_AGAIN_LATER` network is busy, try again later. */
  TryAgainLater = 'TRY_AGAIN_LATER',
  /** `TWITTER_NOT_LINK` the user dose not link the twitter. */
  TwitterNotLink = 'TWITTER_NOT_LINK'
}

/** The `Collect` type provides information about an Essence that has been collected. */
export type Collect = {
  __typename?: 'Collect';
  /** `essence` the essence that was collected. */
  essence: Essence;
  /** `mintingBlock` the block in which the essence was minted. */
  mintingBlock: Scalars['Int'];
  /** `tokenID` the token ID of the collected essence. */
  tokenID: Scalars['Int'];
  /** `transferBlock` the block in which the essence was transferred. */
  transferBlock: Scalars['Int'];
  /** `wallet` the wallet address of the collector. */
  wallet: Wallet;
};

/** The `CollectConnection` type provides a paginated list of `CollectEdge` along with the total count of collected Essenes. */
export type CollectConnection = {
  __typename?: 'CollectConnection';
  /** `edges` list of `CollectEdge` objects. */
  edges?: Maybe<Array<Maybe<CollectEdge>>>;
  /** `pageInfo` contains information about the current page. */
  pageInfo: PageInfo;
  /** `totalCount` the total number of collections. */
  totalCount: Scalars['Int'];
};

/** The `CollectEdge` type provides a `Collect` node along with its cursor. */
export type CollectEdge = {
  __typename?: 'CollectEdge';
  /** `cursor` the cursor of the `Collect` node. */
  cursor: Scalars['Cursor'];
  /** `node` the node of the `Collect` object. */
  node?: Maybe<Collect>;
};

export type CollectEssenceReturnData = {
  __typename?: 'CollectEssenceReturnData';
  /** `collector` the collector address. */
  collector: Scalars['AddressEVM'];
  /** `essenceId` the essence ID that the collector collects. */
  essenceId: Scalars['EssenceID'];
  /** `postData` the post-data of the collect transaction. */
  postData: Scalars['String'];
  /** `preData` the pre-data of the collect transaction. */
  preData: Scalars['String'];
  /** `profileId` the profile ID that the collector collects. */
  profileId: Scalars['ProfileID'];
  /** `tokenId` the essence token ID that the collector collects. */
  tokenId: Scalars['TokenID'];
};

/** The `CollectOrder` input type specifies the order in which results are returned. */
export type CollectOrder = {
  /** `direction` specifies the order direction. */
  direction: OrderDirection;
};

export type Comment = Content & {
  __typename?: 'Comment';
  /** `arweaveTxHash` the transaction hash of the latest version. */
  arweaveTxHash: Scalars['String'];
  /** `authorAddress` the author's address. */
  authorAddress: Scalars['AddressEVM'];
  /** `authorHandle` the author's profile handle. */
  authorHandle: Scalars['String'];
  /** `body` the body of the content. */
  body: Scalars['String'];
  /** `commentCount` the number of comments. */
  commentCount: Scalars['Int'];
  /** `comments` the comments of the content. */
  comments: ContentConnection;
  /** `contentID` the ID of the content. */
  contentID: Scalars['String'];
  /** `createdAt` the time when the content is created. */
  createdAt: Scalars['DateTime'];
  /** `digest` the digest of the content. */
  digest: Scalars['String'];
  /** `dislikeCount` the number of dislikes. */
  dislikeCount: Scalars['Int'];
  /** `likeCount` the number of likes. */
  likeCount: Scalars['Int'];
  /** `liked` whether the current user liked this content. */
  likedStatus: ContentLikeStatus;
  /** `target` the target content of the comment, the content type can be `Post`, `Comment`, or `Essence`. */
  target: Content;
  /** `title` the title of the content. */
  title: Scalars['String'];
  /** `updatedAt` the time when the content is updated. */
  updatedAt: Scalars['DateTime'];
};


export type CommentCommentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


export type CommentLikedStatusArgs = {
  me: Scalars['AddressEVM'];
};

export type Content = {
  /** `commentCount` the number of comments. */
  commentCount: Scalars['Int'];
  /** `comments` the comments of the content. */
  comments: ContentConnection;
  /** `contentID` the ID of the content. */
  contentID: Scalars['String'];
  /** `dislikeCount` the number of dislikes. */
  dislikeCount: Scalars['Int'];
  /** `likeCount` the number of likes. */
  likeCount: Scalars['Int'];
  /** `liked` whether the current user liked this content. */
  likedStatus: ContentLikeStatus;
};


export type ContentCommentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


export type ContentLikedStatusArgs = {
  me: Scalars['AddressEVM'];
};

export type ContentConnection = {
  __typename?: 'ContentConnection';
  /** `edges` the posts in this connection. */
  edges: Array<ContentEdge>;
  /** `pageInfo` the pagination information. */
  pageInfo: PageInfo;
  /** `totalCount` the total number of this post connections. */
  totalCount: Scalars['Int'];
};

export type ContentEdge = {
  __typename?: 'ContentEdge';
  /** `cursor` the cursor for this post. */
  cursor: Scalars['Cursor'];
  /** `node` the post. */
  node: Content;
};

export type ContentLikeStatus = {
  __typename?: 'ContentLikeStatus';
  /** `disliked` whether the current user disliked this post. */
  disliked: Scalars['Boolean'];
  /** `liked` whether the current user liked this post. */
  liked: Scalars['Boolean'];
  /** `proof` the proof of the like or dislike operation. */
  proof?: Maybe<Proof>;
};

export enum ContentType {
  Comment = 'COMMENT',
  Essence = 'ESSENCE',
  Post = 'POST'
}

/** The `Contract` interface provides base details that should be available for all EVM contracts. */
export type Contract = {
  /** The block hash in which the contract was deployed */
  block_hash: Scalars['String'];
  /** The block number in which the contract was deployed */
  block_number: Scalars['Int'];
  /** The bytecode of the contract */
  bytecode: Scalars['String'];
  contractAddress: Scalars['ContractAddressEVM'];
  /** The date the contract was deployed */
  contract_creation_time: Scalars['String'];
  name: Scalars['String'];
};

/** The `CreateCollectEssenceTypedDataInput` input type specifies the params required to collect an essence. */
export type CreateCollectEssenceTypedDataInput = {
  /** `collector` the collector address of the essence. */
  collector: Scalars['AddressEVM'];
  /** `essenceID` the id of the essence that is being collected. */
  essenceID: Scalars['Int'];
  /** `options` the options to collect an essence. */
  options?: InputMaybe<TypedDataOptions>;
  /** `postData` post data send to middleware. formatted in hex with 0x prefix. */
  postData?: InputMaybe<Scalars['String']>;
  /** `preData` pre data send to middleware. formatted in hex with 0x prefix. */
  preData?: InputMaybe<Scalars['String']>;
  /** `profileID` the profile id of the profile that registered the essence. */
  profileID: Scalars['Int'];
};

/** The `CreateCollectEssenceTypedDataResult` type provides the generated EIP-712 spec Typed Data information. */
export type CreateCollectEssenceTypedDataResult = {
  __typename?: 'CreateCollectEssenceTypedDataResult';
  /** `typedData` the EIP-712 spec Typed Data information. */
  typedData: TypedData;
};

/** The `CreateCreateProfileTypedDataInput` input type specifies the params required to create a ccProfile. */
export type CreateCreateProfileTypedDataInput = {
  /** `avatar` the avatar of the ccProfile, should be a valid image link. */
  avatar: Scalars['URL'];
  /** `handle` the handle of the ccProfile. */
  handle: Scalars['String'];
  /** `metadata` the metadata of the ccProfile, should be a valid IPFS CID which points to a valid json file. */
  metadata: Scalars['CID'];
  /** `minHandleLength` specifies minimum handle length. Note! Handle less than 12 characters will be charged with registrant fee provided by your relayer address. Reference: https://docs.cyberconnect.me/cyberconnect/support/faqs#is-minting-a-ccprofile-nft-free */
  minHandleLength?: InputMaybe<Scalars['Int']>;
  /** `operator` the operator address of the ccProfile. In addition to the profile owner, operator address could also help to manage the profile. The field could be void address if no operator is needed. */
  operator: Scalars['AddressEVM'];
  /** `to` the owner address of the ccProfile. */
  to: Scalars['AddressEVM'];
};

/**
 * The `CreateCreateProfileTypedDataResult` type provides the generated EIP-712 spec Typed Data information.
 * Attention, different from other methods, the data does not need to be signed by the user.
 */
export type CreateCreateProfileTypedDataResult = {
  __typename?: 'CreateCreateProfileTypedDataResult';
  /** `typedDataID` the id of the typed data, used to relay. */
  typedDataID: Scalars['ID'];
};

export type CreateFollowTypedMessageInput = {
  /** `address` the from address. */
  address: Scalars['AddressEVM'];
  /** `handle` the target profile's handle. */
  handle: Scalars['String'];
  /** `operation` whether to follow or unfollow. */
  operation: FollowOperation;
};

export type CreateFollowTypedMessageResult = {
  __typename?: 'CreateFollowTypedMessageResult';
  /** `message` the JSON-formatted string message for follow/unfollow actions that require signing. */
  message: Scalars['String'];
};

export type CreateLikeTypedMessageInput = {
  /** `address` the from address. */
  address: Scalars['AddressEVM'];
  /** `contentID` the content ID the user wants to like. */
  contentID: Scalars['String'];
  /** `operation` whether to like or dislike. */
  operation: LikeOperation;
};

export type CreateLikeTypedMessageResult = {
  __typename?: 'CreateLikeTypedMessageResult';
  /** `message` the JSON-formatted string message for like/dislike/cancel actions that require signing. */
  message: Scalars['String'];
};

export type CreateProfileReturnData = {
  __typename?: 'CreateProfileReturnData';
  /** `avatar` the minted profile avatar. */
  avatar: Scalars['String'];
  /** `handle` the minted profile handle. */
  handle: Scalars['String'];
  /** `metadata` the minted profile metadata. */
  metadata: Scalars['CID'];
  /** `profileID` the minted profile ID. */
  profileID: Scalars['ProfileID'];
  /** `profileAddress` the profile holder. */
  to: Scalars['AddressEVM'];
};

export type CreatePublishCommentTypedMessageInput = {
  /** `address` the author's address. */
  address: Scalars['AddressEVM'];
  /** `body` the body of the comment content. */
  body: Scalars['String'];
  /** `handle` the author's profile's handle. */
  handle: Scalars['String'];
  /** `targetContentID` the content ID the user wants to comment. */
  targetContentID: Scalars['String'];
  /** `title` the title of the comment content. */
  title: Scalars['String'];
};

export type CreatePublishCommentTypedMessageResult = {
  __typename?: 'CreatePublishCommentTypedMessageResult';
  /** `message` the JSON-formatted string message for publishComment actions that require signing. */
  message: Scalars['String'];
};

export type CreatePublishPostTypedMessageInput = {
  /** `address` the author's address. */
  address: Scalars['AddressEVM'];
  /** `body` the body of the post content. */
  body: Scalars['String'];
  /** `handle` the author's profile's handle. */
  handle: Scalars['String'];
  /** `title` the title of the post content. */
  title: Scalars['String'];
};

export type CreatePublishPostTypedMessageResult = {
  __typename?: 'CreatePublishPostTypedMessageResult';
  /** `message` the JSON-formatted string message for publishPost actions that require signing. */
  message: Scalars['String'];
};

/** The `CreateRegisterEssenceTypedDataInput` input type specifies the params required to register an essence. */
export type CreateRegisterEssenceTypedDataInput = {
  /** `deployAtRegister` whether the essence contract should be deployed at register, default to false so as to save gas. If set to true, the essence contract will be deployed when someone collects it. */
  deployAtRegister?: InputMaybe<Scalars['Boolean']>;
  /** `middleware` the essence middleware to set. */
  middleware: EssenceMiddleware;
  /** `name` the name of the essence. */
  name: Scalars['String'];
  /** `options` the options to register an essence. */
  options?: InputMaybe<TypedDataOptions>;
  /** `profileID` the id of the profile that is registering the essence. */
  profileID: Scalars['Int'];
  /** `symbol` the symbol of the essence. */
  symbol: Scalars['String'];
  /** `tokenURI` the token URI of the essence NFT. */
  tokenURI: Scalars['URL'];
  /** `transferable` whether the essence is transferable. */
  transferable: Scalars['Boolean'];
};

/** The `CreateRegisterEssenceTypedDataResult` type provides the generated EIP-712 spec Typed Data information. */
export type CreateRegisterEssenceTypedDataResult = {
  __typename?: 'CreateRegisterEssenceTypedDataResult';
  /** `typedData` the EIP-712 spec Typed Data information. */
  typedData: TypedData;
};

/** The `CreateSetEssenceDataTypedDataInput` input type specifies the params required to set the essence data. */
export type CreateSetEssenceDataTypedDataInput = {
  /** `essenceId` the id of the essence that is having its data set. */
  essenceId: Scalars['Int'];
  /** `middleware` the essence middleware to set. */
  middleware: EssenceMiddleware;
  /** `options` the options to set the essence data. */
  options?: InputMaybe<TypedDataOptions>;
  /** `profileId` the id of the profile that is setting the essence data. */
  profileId: Scalars['Int'];
  /** `tokenURI` the token URI of the essence. */
  tokenURI: Scalars['URL'];
};

/** The `CreateSetEssenceDataTypedDataResult` type provides the generated EIP-712 spec Typed Data information. */
export type CreateSetEssenceDataTypedDataResult = {
  __typename?: 'CreateSetEssenceDataTypedDataResult';
  /** `typedData` the EIP-712 spec Typed Data information. */
  typedData: TypedData;
};

/** The `CreateSetMetadataTypedDataInput` input type specifies the params required to set metadata of a ccProfile. */
export type CreateSetMetadataTypedDataInput = {
  /** `metadata` the metadata of the ccProfile, should be a valid IPFS CID which points to a valid json file. */
  metadata: Scalars['CID'];
  /** `options` the options to set the essence data. */
  options?: InputMaybe<TypedDataOptions>;
  /** `profileId` the id of the profile that is setting the metadata. */
  profileId: Scalars['ProfileID'];
};

/** The `CreateSetMetadataTypedDataResult` type provides the generated EIP-712 spec Typed Data information. */
export type CreateSetMetadataTypedDataResult = {
  __typename?: 'CreateSetMetadataTypedDataResult';
  /** `typedData` the EIP-712 spec Typed Data information. */
  typedData: TypedData;
};

/** The `CreateSetSubscribeDataTypedDataInput` input type specifies the params required to set a subscribe middleware. */
export type CreateSetSubscribeDataTypedDataInput = {
  /** `middleware` the subscribe middleware to set. */
  middleware: SubscribeMiddleware;
  /** `options` the options to set a subscribe middleware. */
  options?: InputMaybe<TypedDataOptions>;
  /** `profileId` the ID of the profile setting the subscribe middleware. */
  profileId: Scalars['Int'];
  /** `tokenURI` the token URI of the subscribe NFT. */
  tokenURI: Scalars['URL'];
};

/** The `CreateSetSubscribeDataTypedDataResult` type provides the generated EIP-712 spec Typed Data information. */
export type CreateSetSubscribeDataTypedDataResult = {
  __typename?: 'CreateSetSubscribeDataTypedDataResult';
  /** `typedData` the EIP-712 spec Typed Data information. */
  typedData: TypedData;
};

/** The `CreateSubscribeTypedDataInput` input type specifies the params to subscribe to one or multiple profiles. */
export type CreateSubscribeTypedDataInput = {
  /** `options` the options to subscribe to one or multiple profiles. */
  options?: InputMaybe<TypedDataOptions>;
  /** `profileIDs` the list of profile IDs to subscribe to. */
  profileIDs: Array<Scalars['Int']>;
};

/** The `CreateSubscribeTypedDataResult` type provides the generated EIP-712 spec Typed Data information. */
export type CreateSubscribeTypedDataResult = {
  __typename?: 'CreateSubscribeTypedDataResult';
  /** `typedData` the EIP-712 spec Typed Data information. */
  typedData: TypedData;
};

/** The `DislikeRequest` input type specifies the params required to dislike a content. */
export type DislikeRequest = {
  /** `address` the user's address. */
  address: Scalars['AddressEVM'];
  /** `contentID` the content ID the user wants to dislike. */
  contentID: Scalars['String'];
  /** `message` the JSON-formatted string operation message to sign. */
  message: Scalars['String'];
  /** `signature` the signature from signing the `message`. */
  signature: Scalars['String'];
  /** `signingKey` the registered signing key. */
  signingKey: Scalars['String'];
};

/** The `DislikeResponse` type specifies the response of disliking a content. */
export type DislikeResponse = {
  __typename?: 'DislikeResponse';
  status: DislikeResponse_Status;
  /** `tsInServer` the server generates the timestamp for cases where the timestamp on the client-side is not reliable. */
  tsInServer?: Maybe<Scalars['Timestamp']>;
};

export enum DislikeResponse_Status {
  AlreadyDone = 'ALREADY_DONE',
  ExpiredSigningKey = 'EXPIRED_SIGNING_KEY',
  InvalidMessage = 'INVALID_MESSAGE',
  InvalidParams = 'INVALID_PARAMS',
  InvalidSignature = 'INVALID_SIGNATURE',
  MessageExpired = 'MESSAGE_EXPIRED',
  RateLimited = 'RATE_LIMITED',
  Success = 'SUCCESS',
  TargetNotFound = 'TARGET_NOT_FOUND'
}

/** The `DisplayName` type provides the profile display name on Link3. */
export type DisplayName = {
  __typename?: 'DisplayName';
  /** `type` the type of the display name. */
  type: NameType;
  /** `value` the value of the display name. */
  value: Scalars['String'];
};

/**
 * The `ERC20` type conforms to the standard described in https://ethereum.org/en/developers/docs/standards/tokens/erc-20/.
 * Added fields include symbol, decimals.
 */
export type Erc20 = Contract & {
  __typename?: 'ERC20';
  block_hash: Scalars['String'];
  block_number: Scalars['Int'];
  bytecode: Scalars['String'];
  contractAddress: Scalars['ContractAddressEVM'];
  contract_creation_time: Scalars['String'];
  decimals: Scalars['Int'];
  name: Scalars['String'];
  symbol: Scalars['String'];
};

/**
 * The `ERC721` type conforms to the standard described in https://ethereum.org/en/developers/docs/standards/tokens/erc-721/.
 * Added fields include symbol, decimals.
 */
export type Erc721 = Contract & {
  __typename?: 'ERC721';
  block_hash: Scalars['String'];
  block_number: Scalars['Int'];
  bytecode: Scalars['String'];
  contractAddress: Scalars['ContractAddressEVM'];
  contract_creation_time: Scalars['String'];
  name: Scalars['String'];
  symbol: Scalars['String'];
};

/**
 * The `ERC1155` type conforms to the standard described in https://ethereum.org/en/developers/docs/standards/tokens/erc-1155/.
 * ERC-1155 token can do the same functions as an ERC-20 and ERC-721 token, and even both at the same time.
 */
export type Erc1155 = Contract & {
  __typename?: 'ERC1155';
  block_hash: Scalars['String'];
  block_number: Scalars['Int'];
  bytecode: Scalars['String'];
  contractAddress: Scalars['ContractAddressEVM'];
  contract_creation_time: Scalars['String'];
  name: Scalars['String'];
  symbol: Scalars['String'];
};

export type ErcTransferCard = {
  __typename?: 'ERCTransferCard';
  amount: Scalars['String'];
  block_date: Scalars['String'];
  blockchain: Scalars['String'];
  evt_block_time: Scalars['String'];
  evt_type: Scalars['String'];
  token: TokenInfo;
  tokenId: Scalars['String'];
  token_address: Scalars['String'];
  token_standard: Scalars['String'];
  tx_hash: Scalars['String'];
  unique_tx_id: Scalars['String'];
  wallet_address: Scalars['String'];
};

export enum ErcType {
  /** `ERC721` the ERC721 type. */
  Erc721 = 'ERC721',
  /** `ERC1155` the ERC1155 type. */
  Erc1155 = 'ERC1155'
}

/** The `Essence` type provides information about an essence. */
export type Essence = Content & Node & {
  __typename?: 'Essence';
  /** `collectMw` information about the essence's collect middleware. */
  collectMw: MiddlewareInfo;
  /** `collectedBy` provides a paginated list of profiles that have collected this essence. */
  collectedBy: CollectConnection;
  /** `commentCount` the number of comments. */
  commentCount: Scalars['Int'];
  /** `comments` the comments of the content. */
  comments: ContentConnection;
  /** `contentID` the ID of the content */
  contentID: Scalars['String'];
  /** `contractAddress` the contract address of the essence. null if the contract has not been deployed yet. */
  contractAddress?: Maybe<Scalars['ContractAddressEVM']>;
  /** `createdBy` information about the profile that created this essence. */
  createdBy: Profile;
  /** `dislikeCount` the number of dislikes. */
  dislikeCount: Scalars['Int'];
  /** `essenceID` the essence token id. */
  essenceID: Scalars['Int'];
  /** `id` the unique identifier of the essence. */
  id: Scalars['ID'];
  /** `isCollectedByMe` whether the given address has collected this essence. */
  isCollectedByMe: Scalars['Boolean'];
  /** `likeCount` the number of likes. */
  likeCount: Scalars['Int'];
  /** `liked` whether the current user liked this content. */
  likedStatus: ContentLikeStatus;
  /** `metadata` information about the essence. Only available if the metadata meets the requirements. */
  metadata?: Maybe<EssenceMetadata>;
  /** `name` the name of the essence. */
  name: Scalars['String'];
  /** `symbol` the symbol of the essence. */
  symbol: Scalars['String'];
  /** `tokenURI` the token URI of the essence. */
  tokenURI: Scalars['URL'];
};


/** The `Essence` type provides information about an essence. */
export type EssenceCollectedByArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<CollectOrder>;
};


/** The `Essence` type provides information about an essence. */
export type EssenceCommentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** The `Essence` type provides information about an essence. */
export type EssenceIsCollectedByMeArgs = {
  me: Scalars['AddressEVM'];
};


/** The `Essence` type provides information about an essence. */
export type EssenceLikedStatusArgs = {
  me: Scalars['AddressEVM'];
};

/** The `EssenceConnection` type provides a paginated list of `EssenceEdge` along with the total count of profiles. */
export type EssenceConnection = {
  __typename?: 'EssenceConnection';
  /** `edges` list of `EssenceEdge` objects. */
  edges?: Maybe<Array<Maybe<EssenceEdge>>>;
  /** `pageInfo` contains information about the current page. */
  pageInfo: PageInfo;
  /** `totalCount` the total number of essences. */
  totalCount: Scalars['Int'];
};

/** The `EssenceEdge` type provides an `Essence` node along with its cursor. */
export type EssenceEdge = {
  __typename?: 'EssenceEdge';
  /** `cursor` the cursor of the `Essence` node. */
  cursor: Scalars['Cursor'];
  /** `node` the node of the `Essence` object. */
  node?: Maybe<Essence>;
};

export type EssenceMetadata = {
  __typename?: 'EssenceMetadata';
  /** `animation_url` URL to a multi-media attachment for the item. */
  animation_url?: Maybe<Scalars['URL']>;
  /** `app_id` Id of the application under which the items are being minted. */
  app_id: Scalars['String'];
  /** `attributes` Attributes for the item. */
  attributes?: Maybe<Array<Attribute>>;
  /** `content` The content associated with the item */
  content?: Maybe<Scalars['String']>;
  /** `description` Description of the item. */
  description?: Maybe<Scalars['String']>;
  /** `external_url` URL to the item on your site. */
  external_url?: Maybe<Scalars['URL']>;
  /** `image` URL to the image of the item. */
  image?: Maybe<Scalars['URL']>;
  /** `image_data` SVG image data when the image is not passed. Only use this if you're not including the image parameter. */
  image_data?: Maybe<Scalars['String']>;
  /** `issue_date` Creation time of the item as ISO 8601. */
  issue_date?: Maybe<Scalars['String']>;
  /** `lang` Language of the content as a BCP47 language tag. */
  lang?: Maybe<Scalars['String']>;
  /** `media` Media refers to any image, video, or any other MIME type attached to the content. Limited to max. 10 media objects. */
  media?: Maybe<Array<Media>>;
  /** `metadata_id` Unique id for the issued item */
  metadata_id: Scalars['String'];
  /** `name` Name of the item. */
  name?: Maybe<Scalars['String']>;
  /** `tags` Field indicating the tags associated with the content. Limited to max. 5 tags. */
  tags?: Maybe<Array<Scalars['String']>>;
  /** `version` Version of the metadata schema used for the issued item. Only support `1.0.0` for now. */
  version: Scalars['String'];
};

/** The `EssenceMiddleware` input type specifies the middleware to set. */
export type EssenceMiddleware = {
  /** `collectDisallowed` collecting an essence is disallowed. */
  collectDisallowed?: InputMaybe<Scalars['Boolean']>;
  /** `collectFree` the default module where the collecting an essence is free. */
  collectFree?: InputMaybe<Scalars['Boolean']>;
  /** `collectLimitedTimePaid` collecting an essence requires limited time period and pay a fee. */
  collectLimitedTimePaid?: InputMaybe<CollectLimitedTimePaidMwParams>;
  /** `collectMerkleDrop` collecting an essence requires having a correct merkle proof. */
  collectMerkleDrop?: InputMaybe<CollectMerkleDropMwParams>;
  /** `collectOnlySubscribed` collecting an essence requires the collector to subscribe to the profile that publishes the essence. */
  collectOnlySubscribed?: InputMaybe<Scalars['Boolean']>;
  /** `collectPaid` collecting an essence requires the collector to pay a fee. */
  collectPaid?: InputMaybe<CollectPaidMwParams>;
  /** `collectPermission` collecting an essence requires having a valid signature from the signer. */
  collectPermission?: InputMaybe<CollectPermissionMwParams>;
  /** `collectPermissionPaid` collecting an essence requires having a valid signature from the signer and pay a fee. */
  collectPermissionPaid?: InputMaybe<CollectPermissionPaidMwParams>;
  /** `customMiddleware` for setting a custom middleware. */
  customMiddleware?: InputMaybe<CustomMwParams>;
};

/** The `EssenceOrder` input type specifies the order in which results are returned. */
export type EssenceOrder = {
  /** `direction` specifies the order direction. */
  direction: OrderDirection;
};

/** The `MetadataDetail` type provides information about a profile's metadata on Link3. */
export type ExternalMetadataDetail = {
  __typename?: 'ExternalMetadataDetail';
  /** `organization` the exclusive information about the organization profile on Link3. Take this field if `type` = `ORGANIZATION`. */
  organization?: Maybe<Organization>;
  /** `personal` the exclusive information about the personal profile on Link3. Take this field if `type` = `PERSONAL`. */
  personal?: Maybe<Personal>;
  /** `section` the sections of the profile on Link3. */
  section?: Maybe<Array<Section>>;
  /** `type` the type of the profile. */
  type: ProfileType;
  /** verifiedTwitterID the verified twitter id of the profile. */
  verifiedTwitterID: Scalars['String'];
};

/** The `FollowConnection` type provides a paginated list of `FollowEdge` along with the total count of follow connections. */
export type FollowConnection = {
  __typename?: 'FollowConnection';
  /** `edges` list of `FollowEdge` objects. */
  edges: Array<Maybe<FollowEdge>>;
  /** `pageInfo` contains information about the current page. */
  pageInfo: PageInfo;
  /** `totalCount` the total number of this follow connections. */
  totalCount: Scalars['Int'];
};

/** The `FollowEdge` type provides a `Follow` node along with its cursor. */
export type FollowEdge = {
  __typename?: 'FollowEdge';
  /** `cursor` the cursor of the `Follow` node. */
  cursor: Scalars['Cursor'];
  /** `node` the node of the `Follow` object. */
  node?: Maybe<FollowStatus>;
};

export enum FollowOperation {
  Follow = 'FOLLOW',
  Unfollow = 'UNFOLLOW'
}

/** The `FollowRequest` input type specifies the params required to follow a profile. */
export type FollowRequest = {
  /** `address` the user's address. */
  address: Scalars['AddressEVM'];
  /** `handle` the profile's handle the user wants to follow. */
  handle: Scalars['String'];
  /** `message` the operation json string to sign. */
  message: Scalars['String'];
  /** `signature` the signature from signing the `message` json string. */
  signature: Scalars['String'];
  /** `signingKey` the registered signing key. */
  signingKey: Scalars['String'];
};

/** The `FollowResponse` type returns `follow` request status. */
export type FollowResponse = {
  __typename?: 'FollowResponse';
  status: FollowResponse_Status;
  /** `tsInServer` the server generates the timestamp for cases where the timestamp on the client-side is not reliable. */
  tsInServer?: Maybe<Scalars['Timestamp']>;
};

export enum FollowResponse_Status {
  AlreadyDone = 'ALREADY_DONE',
  ExpiredSigningKey = 'EXPIRED_SIGNING_KEY',
  HandleNotFound = 'HANDLE_NOT_FOUND',
  InvalidMessage = 'INVALID_MESSAGE',
  InvalidParams = 'INVALID_PARAMS',
  InvalidSignature = 'INVALID_SIGNATURE',
  MessageExpired = 'MESSAGE_EXPIRED',
  RateLimited = 'RATE_LIMITED',
  Success = 'SUCCESS'
}

/** The `FollowStatus` type provides information about a follow relationship. */
export type FollowStatus = {
  __typename?: 'FollowStatus';
  /** `address` the source address. */
  address: Address;
  /** `profile` the profile followed by `address`. */
  profile: Profile;
  /** `proof` the proof of the off-chain follow operation. */
  proof?: Maybe<Proof>;
};

export type GalaxyCredential = {
  __typename?: 'GalaxyCredential';
  /** `id` the ID of the Galaxy credential. */
  id: Scalars['String'];
  /** `name` the name of the Galaxy credential. */
  name: Scalars['String'];
};

export type GalaxyCredentialSection = Section & {
  __typename?: 'GalaxyCredentialSection';
  /** `galaxyCredentials` take this field if the `type` is `GALAXY_CREDENTIAL`. */
  galaxyCredentials?: Maybe<Array<GalaxyCredential>>;
  /** `name` the name of the section. */
  name: Scalars['String'];
  /** `type` the type of the section. */
  type: SectionType;
};

export type HackathonVoteResult = {
  __typename?: 'HackathonVoteResult';
  projects: Array<ProjectStatus>;
  status: HackathonVoteResult_Status;
};

export enum HackathonVoteResult_Status {
  Success = 'SUCCESS'
}

/** `Label` type is a generic base type for contract and/or user labels. These can be externally aggregated or internally developed labels. */
export type Label = {
  __typename?: 'Label';
  contractAddress: Scalars['ContractAddressEVM'];
  contractName: Scalars['String'];
  labelName: Scalars['String'];
  labelType: Scalars['String'];
  source: Scalars['String'];
};

export enum LikeOperation {
  Cancel = 'CANCEL',
  Dislike = 'DISLIKE',
  Like = 'LIKE'
}

/** The `LikeRequest` input type specifies the params required to like a content. */
export type LikeRequest = {
  /** `address` the user's address. */
  address: Scalars['AddressEVM'];
  /** `contentID` the content ID the user wants to like. */
  contentID: Scalars['String'];
  /** `message` the JSON-formatted string operation message to sign. */
  message: Scalars['String'];
  /** `signature` the signature from signing the `message`. */
  signature: Scalars['String'];
  /** `signingKey` the registered signing key. */
  signingKey: Scalars['String'];
};

/** The `LikeResponse` type specifies the response of liking a content. */
export type LikeResponse = {
  __typename?: 'LikeResponse';
  status: LikeResponse_Status;
  /** `tsInServer` the server generates the timestamp for cases where the timestamp on the client-side is not reliable. */
  tsInServer?: Maybe<Scalars['Timestamp']>;
};

export enum LikeResponse_Status {
  AlreadyDone = 'ALREADY_DONE',
  ExpiredSigningKey = 'EXPIRED_SIGNING_KEY',
  InvalidMessage = 'INVALID_MESSAGE',
  InvalidParams = 'INVALID_PARAMS',
  InvalidSignature = 'INVALID_SIGNATURE',
  MessageExpired = 'MESSAGE_EXPIRED',
  RateLimited = 'RATE_LIMITED',
  Success = 'SUCCESS',
  TargetNotFound = 'TARGET_NOT_FOUND'
}

export type Link = {
  __typename?: 'Link';
  /** `link` the url of the link. */
  link: Scalars['URL'];
  /** `title` the title of the link. */
  title: Scalars['String'];
};

export type LinkSection = Section & {
  __typename?: 'LinkSection';
  /** `links` take this field if the `type` is `LINK`. */
  links?: Maybe<Array<Link>>;
  /** `name` the name of the section. */
  name: Scalars['String'];
  /** `type` the type of the section. */
  type: SectionType;
};

export type LinkTwitterResult = {
  __typename?: 'LinkTwitterResult';
  /** `status` the result of link twitter. */
  status: LinkTwitterResult_Status;
};

export enum LinkTwitterResult_Status {
  /** `ALREADY_LINKED` user has already linked twitter. */
  AlreadyLinked = 'ALREADY_LINKED',
  /** `INVALID_TOKEN` the twitter auth token is invalid. */
  InvalidToken = 'INVALID_TOKEN',
  /** `NOT_LOGIN` the user is not logged in. */
  NotLogin = 'NOT_LOGIN',
  /** `SUCCESS` link twitter successfully. */
  Success = 'SUCCESS',
  /** `TWITTER_USED` the twitter is linked by others. */
  TwitterUsed = 'TWITTER_USED'
}

export type LinkedTwitterResult = {
  __typename?: 'LinkedTwitterResult';
  /** `status` the result of query user linked twitter. */
  status: LinkedTwitterResult_Status;
  /** `twitterId` the user linked twitter id. */
  twitterId?: Maybe<Scalars['String']>;
};

export enum LinkedTwitterResult_Status {
  /** `NOT_LOGIN` the user is not logged in. */
  NotLogin = 'NOT_LOGIN',
  /** `SUCCESS` query user linked twitter successfully. */
  Success = 'SUCCESS'
}

/** The `LoginGetMessageInput` input type specifies the Typed Data message parameters. */
export type LoginGetMessageInput = {
  /** `address` the address of the user. */
  address: Scalars['AddressEVM'];
  /** `domain` the domain of the app. */
  domain: Scalars['String'];
};

/** The `LoginGetMessageResult` type provides an EIP-712 spec Typed Data message to sign with a wallet. */
export type LoginGetMessageResult = {
  __typename?: 'LoginGetMessageResult';
  /** `message` the EIP-712 spec Typed Data message to sign with a wallet. */
  message: Scalars['String'];
};

/** The `LoginVerifyInput` input type specifies the Typed Data message parameters along with it's signature. */
export type LoginVerifyInput = {
  /** `address` the address of the user. */
  address: Scalars['AddressEVM'];
  /** `domain` the domain of the app. */
  domain: Scalars['String'];
  /** `isEIP1271` whether verify signature in the way of EIP-1271. */
  isEIP1271?: InputMaybe<Scalars['Boolean']>;
  /** `signature` the signature of the message. */
  signature: Scalars['String'];
};

/** The `LoginVerifyResult` type provides an access token for mutation requests that require authentication. */
export type LoginVerifyResult = {
  __typename?: 'LoginVerifyResult';
  /** `accessToken` the access token for mutation requests that require authentication. */
  accessToken: Scalars['String'];
  /** `refreshToken` the refresh token for refresh accessToken. */
  refreshToken: Scalars['String'];
};

export type Media = {
  __typename?: 'Media';
  /** `alt_tag` alternative text when media can't be rendered */
  alt_tag?: Maybe<Scalars['String']>;
  /** `media_type`the MIME type for the media  */
  media_type: Scalars['String'];
  /** `media_url` the URL link for the media  */
  media_url: Scalars['String'];
  /** `preview_image_url` the preview image for the media */
  preview_image_url?: Maybe<Scalars['String']>;
};

/** The `VerifyEssenceMetadataInput` input type specifies the params required to verify an essence's metadata. */
export type MediaInput = {
  /** `alt_tag` alternative text when media can't be rendered */
  alt_tag?: InputMaybe<Scalars['String']>;
  /** `media_type`the MIME type for the media  */
  media_type: Scalars['String'];
  /** `media_url` the URL link for the media  */
  media_url: Scalars['String'];
  /** `preview_image_url` the preview image for the media */
  preview_image_url?: InputMaybe<Scalars['String']>;
};

/** The `Mention` type provides the data in the mention sections of Link3 profiles. */
export type Mention = {
  __typename?: 'Mention';
  /** `description` the description of the twitter. */
  description: Scalars['String'];
  /** `title` the title of the twitter. */
  title: Scalars['String'];
  /** `twitter` the Twitter account info in the mention section. */
  twitter: Twitter;
};

export type MentionSection = Section & {
  __typename?: 'MentionSection';
  /** `mentions` take this field if the `type` is `MENTION`. */
  mentions?: Maybe<Array<Mention>>;
  /** `name` the name of the section. */
  name: Scalars['String'];
  /** `type` the type of the section. */
  type: SectionType;
};

/** The `MetadataDetail` type provides information about a profile's metadata. */
export type MetadataDetail = {
  __typename?: 'MetadataDetail';
  /** `attributes` Attributes for the item. */
  attributes?: Maybe<Array<Attribute>>;
  /** `avatar` the avatar of the profile. */
  avatar: Scalars['String'];
  /** `bio` the bio of the profile. */
  bio: Scalars['String'];
  /** `coverImage` the cover image of the profile. */
  coverImage: Scalars['String'];
  /** `displayName` the displayName of the profile. */
  displayName: Scalars['String'];
  /** `version` the version of the profile. */
  version: Scalars['String'];
};

export type Metric = {
  __typename?: 'Metric';
  totalComments: Scalars['Int'];
  totalEssences: Scalars['Int'];
  totalFollows: Scalars['Int'];
  totalLikes: Scalars['Int'];
  totalPosts: Scalars['Int'];
  totalProfiles: Scalars['Int'];
  totalSubscriptions: Scalars['Int'];
};

/** The `MiddlewareInfo` type provides information about a middleware. */
export type MiddlewareInfo = {
  __typename?: 'MiddlewareInfo';
  /** `contractAddress` the middleware contract address. */
  contractAddress: Scalars['ContractAddressEVM'];
  /** `data` the middleware data. */
  data: Scalars['String'];
  /** `type` the middleware type. */
  type: MiddlewareType;
};

export enum MiddlewareType {
  CollectDisallowed = 'COLLECT_DISALLOWED',
  CollectFree = 'COLLECT_FREE',
  CollectLimitedTimePaid = 'COLLECT_LIMITED_TIME_PAID',
  CollectMerkleDrop = 'COLLECT_MERKLE_DROP',
  CollectOnlySubscribed = 'COLLECT_ONLY_SUBSCRIBED',
  CollectPaid = 'COLLECT_PAID',
  CollectPermission = 'COLLECT_PERMISSION',
  CollectPermissionPaid = 'COLLECT_PERMISSION_PAID',
  SubscribeDisallowed = 'SUBSCRIBE_DISALLOWED',
  SubscribeFree = 'SUBSCRIBE_FREE',
  SubscribeOnlyOnce = 'SUBSCRIBE_ONLY_ONCE',
  SubscribePaid = 'SUBSCRIBE_PAID',
  Unknown = 'UNKNOWN'
}

export type Mutation = {
  __typename?: 'Mutation';
  ackVote: AckVoteResponse;
  /** `cancelLike` cancel a like or dislike. */
  cancelLike: CancelLikeResponse;
  /** `claimCyberProfile` claims a cyber profile with the given params and a promo code. The server will send the mint transaction. */
  claimCyberProfileWithPromoCode: ClaimCyberProfileWithPromoCodeResult;
  /** `claimCyberProfileWithTwitter` claims a cyber profile with the given params. During the hackathon, users can free and gasless mint the profile with the 12-length or above handle by linking twitter */
  claimCyberProfileWithTwitter: ClaimCyberProfileWithTwitterResult;
  /** `createCollectEssenceTypedData` returns an EIP-712 spec Typed Data message to sign with a wallet in order to collect an essence. This mutation requires an `Authorization` header with a valid `Bearer` token. */
  createCollectEssenceTypedData: CreateCollectEssenceTypedDataResult;
  /** `createCreateProfileTypedData` returns an EIP-712 spec Typed Data message in order to create a ccProfile. This mutation requires an `Authorization` header with a valid `Bearer` token. */
  createCreateProfileTypedData: CreateCreateProfileTypedDataResult;
  /** `createRegisterEssenceTypedData` returns an EIP-712 spec Typed Data message to sign with a wallet in order to register an essence. This mutation requires an `Authorization` header with a valid `Bearer` token. */
  createRegisterEssenceTypedData: CreateRegisterEssenceTypedDataResult;
  /** `createSetEssenceDataTypedData` returns an EIP-712 spec Typed Data message to sign with a wallet in order to set the essence data. This mutation requires an `Authorization` header with a valid `Bearer` token. */
  createSetEssenceDataTypedData: CreateSetEssenceDataTypedDataResult;
  /** `createSetMetadataTypedData` returns an EIP-712 spec Typed Data message to sign with a wallet in order to set metadata of the ccProfile. This mutation requires an `Authorization` header with a valid `Bearer` token. */
  createSetMetadataTypedData: CreateSetMetadataTypedDataResult;
  /** `createSetSubscribeDataTypedData` returns an EIP-712 spec Typed Data message to sign with a wallet in order to set the subscribe data middleware. This mutation requires an `Authorization` header with a valid `Bearer` token. */
  createSetSubscribeDataTypedData: CreateSetSubscribeDataTypedDataResult;
  /** `createSubscribeTypedData` returns an EIP-712 spec Typed Data message to sign with a wallet in order to subscribe to one or multiple profiles. This mutation requires an `Authorization` header with a valid `Bearer` token. */
  createSubscribeTypedData: CreateSubscribeTypedDataResult;
  /** `dislike` dislike a content. */
  dislike: DislikeResponse;
  /** `follow` follow an profile handle. */
  follow: FollowResponse;
  /** `like` like a content. */
  like: LikeResponse;
  /** `linkTwitter` links twitter with address. CANNOT RELINK. address which linked twitter can free and gasless mint the profile with the 12-length or above handle. */
  linkTwitter: LinkTwitterResult;
  /** `loginGetMessage` returns an EIP-712 spec Typed Data message to sign with a wallet based on the Typed Data Message Parameters input. */
  loginGetMessage: LoginGetMessageResult;
  /** `loginVerify` returns an access token for mutation requests that require authentication based on the signed Typed Data message input. */
  loginVerify: LoginVerifyResult;
  /** `publishComment` comment to a content, or update an existing comment. */
  publishComment: PublishResponse;
  /** `publishPost` publish a new post, or update an existing post. */
  publishPost: PublishResponse;
  /** `refreshAccessToken` returns a new access token and a new refresh token based on the refresh token input. */
  refreshAccessToken: RefreshAccessTokenResult;
  /** `registerSigningKey` registers a signing key to use with `follow` and `unfollow` inputs. */
  registerSigningKey: RegisterSigningKeyResponse;
  /** `relay` broadcasts a transaction to the EVM chain. This mutation requires an `Authorization` header with a valid `Bearer` token. */
  relay: RelayResult;
  /** `revokeSigningKey` revokes a signing key. */
  revokeSigningKey: RevokeSigningKeyResponse;
  /** `saveTweet` save tweet link of which the author is linked twitter. Qualified tweet are able to win rewards. */
  saveTweet: SaveTweetResult;
  /** `tweetNonce` get nonce only for tweet verify. */
  tweetNonce: TweetNonceResult;
  /** `unfollow` unfollow an profile handle. */
  unfollow: UnFollowResponse;
  vote: VoteResponse;
};


export type MutationAckVoteArgs = {
  input: AckVoteRequest;
};


export type MutationCancelLikeArgs = {
  input: CancelLikeRequest;
};


export type MutationClaimCyberProfileWithPromoCodeArgs = {
  input: ClaimCyberProfileWithPromoCodeInput;
};


export type MutationClaimCyberProfileWithTwitterArgs = {
  input: ClaimCyberProfileWithTwitterInput;
};


export type MutationCreateCollectEssenceTypedDataArgs = {
  input: CreateCollectEssenceTypedDataInput;
};


export type MutationCreateCreateProfileTypedDataArgs = {
  input: CreateCreateProfileTypedDataInput;
};


export type MutationCreateRegisterEssenceTypedDataArgs = {
  input: CreateRegisterEssenceTypedDataInput;
};


export type MutationCreateSetEssenceDataTypedDataArgs = {
  input: CreateSetEssenceDataTypedDataInput;
};


export type MutationCreateSetMetadataTypedDataArgs = {
  input: CreateSetMetadataTypedDataInput;
};


export type MutationCreateSetSubscribeDataTypedDataArgs = {
  input: CreateSetSubscribeDataTypedDataInput;
};


export type MutationCreateSubscribeTypedDataArgs = {
  input: CreateSubscribeTypedDataInput;
};


export type MutationDislikeArgs = {
  input: DislikeRequest;
};


export type MutationFollowArgs = {
  input: FollowRequest;
};


export type MutationLikeArgs = {
  input: LikeRequest;
};


export type MutationLinkTwitterArgs = {
  authToken: Scalars['String'];
};


export type MutationLoginGetMessageArgs = {
  input: LoginGetMessageInput;
};


export type MutationLoginVerifyArgs = {
  input: LoginVerifyInput;
};


export type MutationPublishCommentArgs = {
  contentID?: InputMaybe<Scalars['String']>;
  input: PublishRequest;
  targetContentID: Scalars['String'];
};


export type MutationPublishPostArgs = {
  contentID?: InputMaybe<Scalars['String']>;
  input: PublishRequest;
};


export type MutationRefreshAccessTokenArgs = {
  input: RefreshAccessTokenInput;
};


export type MutationRegisterSigningKeyArgs = {
  input: RegisterSigningKeyRequest;
};


export type MutationRelayArgs = {
  input: RelayInput;
};


export type MutationRevokeSigningKeyArgs = {
  input: RevokeSigningKeyRequest;
};


export type MutationSaveTweetArgs = {
  input: SaveTweetInput;
};


export type MutationUnfollowArgs = {
  input: UnFollowRequest;
};


export type MutationVoteArgs = {
  projectName: Scalars['String'];
};

/** The `NFT` type provides the NFT data. */
export type Nft = {
  __typename?: 'NFT';
  /** `chainId` the chain ID of the NFT. */
  chainId: Scalars['ChainID'];
  /** `contract` the contract address of the NFT. */
  contract: Scalars['ContractAddressEVM'];
  /** `image` the content or url of the NFT image. */
  image: Scalars['String'];
  /** `name` the name of the NFT. */
  name: Scalars['String'];
  /** `owner` the owner's address of the NFT. */
  owner: Scalars['AddressEVM'];
  /** `tokenId` the token ID of the NFT. */
  tokenId: Scalars['String'];
  /** `type` the ERC type of the NFT. */
  type: ErcType;
};

export type NftCollectionSection = Section & {
  __typename?: 'NFTCollectionSection';
  /** `name` the name of the section. */
  name: Scalars['String'];
  /** `slug` take this field if the `type` is `NFT_COLLECTION`. */
  slug: Scalars['String'];
  /** `type` the type of the section. */
  type: SectionType;
};

export type NftSection = Section & {
  __typename?: 'NFTSection';
  /** `name` the name of the section. */
  name: Scalars['String'];
  /** `nfts` take this field if the `type` is `NFT_GALLERY`. */
  nfts?: Maybe<Array<Nft>>;
  /** `type` the type of the section. */
  type: SectionType;
};

/** The `NameType` enum type provides the profile name type. */
export enum NameType {
  /** `ENS` an ENS name. */
  Ens = 'ENS',
  /** `GENERAL` a standard name. */
  General = 'GENERAL',
  /** `SPACE_ID` a .bnb name. */
  SpaceId = 'SPACE_ID'
}

/** The `Namespace` type provides information about a namespace. */
export type Namespace = Node & {
  __typename?: 'Namespace';
  /** `chainId` the chain ID of the network this namespace is created on. */
  chainID: Scalars['ChainID'];
  /** `contractAddress` the address of the namespace's contract. */
  contractAddress: Scalars['ContractAddressEVM'];
  /** `descriptorContract` the address of the namespace's descriptor contract. */
  descriptorContract: Scalars['ContractAddressEVM'];
  /** `id` the namespace's unique identifier. */
  id: Scalars['ID'];
  /** `name` the namespace's name. */
  name: Scalars['String'];
};

/** The `Node` interface follows relay.dev spec. */
export type Node = {
  /** `id` the unique identifier for the Node object. */
  id: Scalars['ID'];
};

/** The `OrderDirection` enum type provides sorting directions. */
export enum OrderDirection {
  /** `ASC` sort in ascending order. */
  Asc = 'ASC',
  /** `DESC` sort in descending order. */
  Desc = 'DESC'
}

/** The `Organization` type provides the exclusive information about organization profile on Link3. */
export type Organization = {
  __typename?: 'Organization';
  /** `cmcTokenId` the CoinMarketCap token ID of the token issued by the organization's project. */
  cmcTokenId: Scalars['String'];
  /** `networks` the blockchains the organization's project is based on. */
  networks: Array<Scalars['String']>;
  /** `sector` the subdivision area of the organization's project. */
  sector: Scalars['String'];
};

export type Poap = {
  __typename?: 'POAP';
  /** `id` the ID of the POAP. */
  id: Scalars['String'];
  /** `image` the image of the POAP. */
  image: Scalars['URL'];
};

/** The `PageInfo` type provides pagination info for lists. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** `endCursor` the cursor of the last item in the current page. */
  endCursor?: Maybe<Scalars['Cursor']>;
  /** `hasNextPage` whether there are results in the connection after the current page. */
  hasNextPage: Scalars['Boolean'];
  /** `hasPreviousPage` whether there are results in the connection before the current page.. */
  hasPreviousPage: Scalars['Boolean'];
  /** `startCursor` the cursor of the first item in the current page. */
  startCursor?: Maybe<Scalars['Cursor']>;
};

/** The `Personal` type provides the exclusive information about personal profile on Link3. */
export type Personal = {
  __typename?: 'Personal';
  /** `organization` the organization of the profile. */
  organization?: Maybe<Twitter>;
  /** `title` the title in the organization of the profile. */
  title: Scalars['String'];
  /** `verifiedDiscordID` the verified Discord ID of the profile. */
  verifiedDiscordID: Scalars['String'];
};

/** The `Picture` type provides the picture on Link3. Take different values according to the `type` field. */
export type Picture = {
  __typename?: 'Picture';
  /** `image` a general image. Take this field if `type` = `GENERAL`. */
  image?: Maybe<Scalars['URL']>;
  /** `nfts` an image consists of one or more NFTs. Take this field if `type` = `NFT`. */
  nfts?: Maybe<Array<Nft>>;
  /** `type` the type of the picture. */
  type: AvatarType;
};

export type PoapSection = Section & {
  __typename?: 'PoapSection';
  /** `name` the name of the section. */
  name: Scalars['String'];
  /** `poaps` take this field if the `type` is `POAP`. */
  poaps?: Maybe<Array<Poap>>;
  /** `type` the type of the section. */
  type: SectionType;
};

export type Post = Content & {
  __typename?: 'Post';
  /** `arweaveTxHash` the transaction hash of the latest version. */
  arweaveTxHash: Scalars['String'];
  /** `authorAddress` the author's address. */
  authorAddress: Scalars['AddressEVM'];
  /** `authorHandle` the author's profile handle. */
  authorHandle: Scalars['String'];
  /** `body` the body of the content. */
  body: Scalars['String'];
  /** `commentCount` the number of comments. */
  commentCount: Scalars['Int'];
  /** `comments` the comments of the content. */
  comments: ContentConnection;
  /** `contentID` the ID of the content. */
  contentID: Scalars['String'];
  /** `createdAt` the time when the content is created. */
  createdAt: Scalars['DateTime'];
  /** `digest` the digest of the content. */
  digest: Scalars['String'];
  /** `dislikeCount` the number of dislikes. */
  dislikeCount: Scalars['Int'];
  /** `likeCount` the number of likes. */
  likeCount: Scalars['Int'];
  /** `liked` whether the current user liked this content. */
  likedStatus: ContentLikeStatus;
  /** `title` the title of the content. */
  title: Scalars['String'];
  /** `updatedAt` the time when the content is updated. */
  updatedAt: Scalars['DateTime'];
};


export type PostCommentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


export type PostLikedStatusArgs = {
  me: Scalars['AddressEVM'];
};

/** The `Profile` type provides information about a profile. */
export type Profile = Node & {
  __typename?: 'Profile';
  /** `avatar` the profile's avatar url. */
  avatar?: Maybe<Scalars['URL']>;
  /** `commentCount` the number of comments */
  commentCount: Scalars['Int'];
  /** `comments` the comments created by the profile. */
  comments: ContentConnection;
  /** `essence` provides the specific essence by essenceID. */
  essence?: Maybe<Essence>;
  /** `essences` provides a paginated list of ordered essences. */
  essences: EssenceConnection;
  /** `externalMetadataInfo` information about the profile's metadata on Link3. */
  externalMetadataInfo?: Maybe<ExternalMetadataDetail>;
  /** `followerCount` the number of followers. */
  followerCount: Scalars['Int'];
  /** `followers` provides a paginated list of ordered followers. */
  followers: FollowConnection;
  /** `handle` the profile's handle. */
  handle: Scalars['String'];
  /** `id` the profile's unique identifier. */
  id: Scalars['ID'];
  /** `isFollowedByMe` whether the given address has followed the profile. */
  isFollowedByMe: Scalars['Boolean'];
  /** `isPrimary` whether the profile is the primary profile of the owner. */
  isPrimary: Scalars['Boolean'];
  /** `isSubscribedByMe` whether the given address has subscribed to the profile. */
  isSubscribedByMe: Scalars['Boolean'];
  /** `metadata` the profile's metadata url. */
  metadata?: Maybe<Scalars['String']>;
  /** `metadataInfo` information about the profile's metadata. */
  metadataInfo?: Maybe<MetadataDetail>;
  /** `mintingBlock` the block number when the profile was minted. */
  mintingBlock: Scalars['Int'];
  /** `namespace` information about the profile's namespace. */
  namespace: Namespace;
  /** `operators` the profile's list of operator addresses */
  operators: Array<Scalars['AddressEVM']>;
  /** `owner` the profile's owner wallet. */
  owner: Wallet;
  /** `postCount` the number of posts */
  postCount: Scalars['Int'];
  /** `posts` the posts created by the profile. */
  posts: ContentConnection;
  /** `profileID` the profile's token id. */
  profileID: Scalars['Int'];
  /** `subscribeMw` information about the profile's subscribe middleware. */
  subscribeMw?: Maybe<MiddlewareInfo>;
  /** `subscribeNFT` the profile's subscribe NFT contract address. */
  subscribeNFT?: Maybe<Scalars['ContractAddressEVM']>;
  /** `subscriberCount` the number of subscribers. */
  subscriberCount: Scalars['Int'];
  /** `subscribers` provides a paginated list of ordered subscribers. */
  subscribers: SubscribeConnection;
};


/** The `Profile` type provides information about a profile. */
export type ProfileCommentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** The `Profile` type provides information about a profile. */
export type ProfileEssenceArgs = {
  essenceID: Scalars['EssenceID'];
};


/** The `Profile` type provides information about a profile. */
export type ProfileEssencesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  appID?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<EssenceOrder>;
};


/** The `Profile` type provides information about a profile. */
export type ProfileFollowersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** The `Profile` type provides information about a profile. */
export type ProfileIsFollowedByMeArgs = {
  me: Scalars['AddressEVM'];
};


/** The `Profile` type provides information about a profile. */
export type ProfileIsSubscribedByMeArgs = {
  me: Scalars['AddressEVM'];
};


/** The `Profile` type provides information about a profile. */
export type ProfilePostsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
};


/** The `Profile` type provides information about a profile. */
export type ProfileSubscribersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SubscribeOrder>;
};

/** The `ProfileConnection` type provides a paginated list of `ProfileEdge` along with the total count of profiles. */
export type ProfileConnection = {
  __typename?: 'ProfileConnection';
  /** `edges` list of `ProfileEdge` objects. */
  edges?: Maybe<Array<Maybe<ProfileEdge>>>;
  /** `pageInfo` contains information about the current page. */
  pageInfo: PageInfo;
  /** `totalCount` the total number of profiles. */
  totalCount: Scalars['Int'];
};

/** The `SubscribeEdge` type provides a `Profile` node along with its cursor. */
export type ProfileEdge = {
  __typename?: 'ProfileEdge';
  /** `cursor` the cursor of the `Profile` node. */
  cursor: Scalars['Cursor'];
  /** `node` the node of the `Profile` object. */
  node?: Maybe<Profile>;
};

export type ProfileHandleEligibility = {
  __typename?: 'ProfileHandleEligibility';
  /** `status` the check result of the handle eligibility. */
  status: ProfileHandleEligibility_Status;
};

export enum ProfileHandleEligibility_Status {
  /** `ALREADY_CLAIMED` the user has already claimed handle. */
  AlreadyClaimed = 'ALREADY_CLAIMED',
  /** `CLAIMING_OTHER_HANDLE` the user is claiming another handle, should wait for the handle to be unlocked if the user wants to claim a new handle. */
  ClaimingOtherHandle = 'CLAIMING_OTHER_HANDLE',
  /** `CLAIM_IN_PROGRESS_BY_OTHER` the handle is being claimed by another user. */
  ClaimInProgressByOther = 'CLAIM_IN_PROGRESS_BY_OTHER',
  /** `INVALID_HANDLE_FORMAT` the handle format is invalid. */
  InvalidHandleFormat = 'INVALID_HANDLE_FORMAT',
  /** `NOT_LOGIN` the user is not logged in. */
  NotLogin = 'NOT_LOGIN',
  /** `REGISTERED_HANDLE` the handle is already registered. */
  RegisteredHandle = 'REGISTERED_HANDLE',
  /** `RESERVED_HANDLE` the handle is reserved. */
  ReservedHandle = 'RESERVED_HANDLE',
  /** `SUCCESS` the handle is eligible. */
  Success = 'SUCCESS'
}

/** The `ProfileOrder` input type specifies the order in which results are returned. */
export type ProfileOrder = {
  /** `direction` specifies the order direction. */
  direction: OrderDirection;
  /** `field` specifies the order field. */
  field?: InputMaybe<ProfileOrderField>;
};

/** The `ProfileOrderField` enum type provides sorting directions for the list of profiles. */
export enum ProfileOrderField {
  /** `PROFILE_ID` sort by the `profileId` field. */
  ProfileId = 'PROFILE_ID'
}

/** The `ProfileType` enum type provides the profile type. */
export enum ProfileType {
  /** `ORGANIZATION` organization profile. */
  Organization = 'ORGANIZATION',
  /** `PERSONAL` personal profile. */
  Personal = 'PERSONAL'
}

/** `ProjectLevelInteraction` is a label describing an addresses interactions with a given project. */
export type ProjectLevelInteraction = {
  __typename?: 'ProjectLevelInteraction';
  firstInteraction: Scalars['String'];
  lastInteraction: Scalars['String'];
  numReceived: Scalars['Int'];
  numSent: Scalars['Int'];
  project: Scalars['String'];
  sampleTxHashes?: Maybe<Array<Scalars['String']>>;
  txCount: Scalars['Int'];
};

export type ProjectStatus = {
  __typename?: 'ProjectStatus';
  description: Scalars['String'];
  link3Handle?: Maybe<Scalars['String']>;
  logo: Scalars['String'];
  projectName: Scalars['String'];
  votedCount: Scalars['Int'];
};

export type Proof = {
  __typename?: 'Proof';
  /** `arweaveTxHash` the transaction hash of the latest version. */
  arweaveTxHash: Scalars['String'];
  content: Scalars['String'];
  digest: Scalars['String'];
  signature: Scalars['String'];
  signingKey: Scalars['String'];
  signingKeyAuth: SigningKeyAuth;
};

export type PublishRequest = {
  /** `authorAddress` the author's address. */
  authorAddress: Scalars['AddressEVM'];
  /** `authorHandle` the author's profile handle. */
  authorHandle: Scalars['String'];
  /** `message` the JSON-formatted string message for publishing a post. */
  message: Scalars['String'];
  /** `signature` the signature from signing the `message`. */
  signature: Scalars['String'];
  /** `signingKey` the registered signing key. */
  signingKey: Scalars['String'];
};

export type PublishResponse = {
  __typename?: 'PublishResponse';
  /** `arweaveTxHash` the transaction hash of the published post on Arweave. */
  arweaveTxHash: Scalars['String'];
  /** `contentID` the ID of the post. */
  contentID: Scalars['String'];
  status: PublishResponse_Status;
  /** `tsInServer` the server generates the timestamp for cases where the timestamp on the client-side is not reliable. */
  tsInServer?: Maybe<Scalars['Timestamp']>;
};

export enum PublishResponse_Status {
  AlreadyExisted = 'ALREADY_EXISTED',
  ContentNotFound = 'CONTENT_NOT_FOUND',
  ExpiredSigningKey = 'EXPIRED_SIGNING_KEY',
  HandleNotFound = 'HANDLE_NOT_FOUND',
  InvalidMessage = 'INVALID_MESSAGE',
  InvalidParams = 'INVALID_PARAMS',
  InvalidSignature = 'INVALID_SIGNATURE',
  InvalidSigningKey = 'INVALID_SIGNING_KEY',
  MessageExpired = 'MESSAGE_EXPIRED',
  NotProfileOwner = 'NOT_PROFILE_OWNER',
  RateLimited = 'RATE_LIMITED',
  Success = 'SUCCESS',
  TargetNotFound = 'TARGET_NOT_FOUND'
}

export type Query = {
  __typename?: 'Query';
  /** `address` returns the information about an EVM address */
  address?: Maybe<Address>;
  /** `batchGetAddresses` returns information about a list of EVM addresses. */
  batchGetAddresses: Array<Address>;
  /** `content` get a content by its ID. */
  content?: Maybe<Content>;
  /** `createFollowTypedMessage` create a typed message for follow/unfollow actions that require signing. */
  createFollowTypedMessage: CreateFollowTypedMessageResult;
  /** `createLikeTypedMessage` create a typed message for like/dislike/cancel actions that require signing. */
  createLikeTypedMessage: CreateLikeTypedMessageResult;
  /** `createPublishCommentTypedMessage` create a typed message for publishComment actions that require signing. */
  createPublishCommentTypedMessage: CreatePublishCommentTypedMessageResult;
  /** `createPublishPostTypedMessage` create a typed message for publishPost actions that require signing. */
  createPublishPostTypedMessage: CreatePublishPostTypedMessageResult;
  essencesBy: EssenceConnection;
  /** `hackathonVote` get hackathon vote status */
  hackathonVote: HackathonVoteResult;
  /** `linkedTwitter` checks user linked twitter */
  linkedTwitter: LinkedTwitterResult;
  metrics: Metric;
  /** `node` returns information about a node based on a `node ID`. */
  node?: Maybe<Node>;
  /** `nodes` returns a list of nodes based on a set of `node IDs`. */
  nodes: Array<Maybe<Node>>;
  /** `profileByHandle` provides information about a profile based on the profile's `handle` input. */
  profileByHandle?: Maybe<Profile>;
  /** `profileByID` provides information about a profile based on the profile's `profileID` input. */
  profileByID?: Maybe<Profile>;
  /** `profileHandleEligibility` checks if the handle is eligible to be claimed. */
  profileHandleEligibility: ProfileHandleEligibility;
  /** `profiles` provides a paginated list of ordered profiles. */
  profiles: ProfileConnection;
  /** `profilesByHandles` provides information about the profiles based on the profiles' `handles` list input. */
  profilesByHandles?: Maybe<Array<Maybe<Profile>>>;
  /** `profilesByIDs` provides information about the profiles based on the profiles' `profileIDs` list input. */
  profilesByIDs?: Maybe<Array<Maybe<Profile>>>;
  /** `relayActionStatus` returns the relay action status. */
  relayActionStatus?: Maybe<RelayActionStatusResultUnion>;
  /** `savedTweet` checks user saved tweet */
  savedTweet: SavedTweetResult;
  searchEssences: EssenceConnection;
  /** `signingKeys` returns a list of signing keys. */
  signingKeys?: Maybe<Array<SigningKey>>;
  /** `syncedAt` returns the block information about the latest block when it was last synced. */
  syncedAt: BlockchainTime;
  /** `systemStatus` returns information about the last synced block height. */
  systemStatus?: Maybe<SystemStatus>;
  /** `userStatistics` get user statistics */
  userStatistics: UserStatisticsResult;
  /** `userVoteStatus` get user vote status */
  userVoteStatus: UserVoteStatusResult;
  /** `verifyAccessToken` verifies if the access token is valid based on the access token input. */
  verifyAccessToken: VerifyAccessTokenResult;
  /** `verifyEssenceMetadata` verifies the validity of an essence's metadata. */
  verifyEssenceMetadata: VerifyEssenceMetadataResult;
};


export type QueryAddressArgs = {
  address: Scalars['AddressEVM'];
};


export type QueryBatchGetAddressesArgs = {
  addresses: Array<Scalars['AddressEVM']>;
};


export type QueryContentArgs = {
  id: Scalars['String'];
};


export type QueryCreateFollowTypedMessageArgs = {
  input: CreateFollowTypedMessageInput;
};


export type QueryCreateLikeTypedMessageArgs = {
  input: CreateLikeTypedMessageInput;
};


export type QueryCreatePublishCommentTypedMessageArgs = {
  input: CreatePublishCommentTypedMessageInput;
};


export type QueryCreatePublishPostTypedMessageArgs = {
  input: CreatePublishPostTypedMessageInput;
};


export type QueryEssencesByArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  appID?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['Cursor']>;
  contractAddress?: InputMaybe<Scalars['ContractAddressEVM']>;
  first?: InputMaybe<Scalars['Int']>;
  lang?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  metadataID?: InputMaybe<Scalars['String']>;
  orderBy?: InputMaybe<EssenceOrder>;
};


export type QueryNodeArgs = {
  id: Scalars['ID'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']>;
};


export type QueryProfileByHandleArgs = {
  handle: Scalars['String'];
};


export type QueryProfileByIdArgs = {
  profileID: Scalars['ProfileID'];
};


export type QueryProfileHandleEligibilityArgs = {
  handle: Scalars['String'];
};


export type QueryProfilesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ProfileOrder>;
};


export type QueryProfilesByHandlesArgs = {
  handles: Array<Scalars['String']>;
};


export type QueryProfilesByIDsArgs = {
  profileIDs: Array<Scalars['ProfileID']>;
};


export type QueryRelayActionStatusArgs = {
  relayActionId: Scalars['ID'];
};


export type QuerySearchEssencesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  keyword: Scalars['String'];
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<EssenceOrder>;
};


export type QueryVerifyAccessTokenArgs = {
  input: VerifyAccessTokenInput;
};


export type QueryVerifyEssenceMetadataArgs = {
  input: VerifyEssenceMetadataInput;
};

/** The `Recommendation` type is the base for finding all information that might be interesting/attractive to a given address based on historical transaction history & current balance. */
export type Recommendation = {
  __typename?: 'Recommendation';
  /** `tokenBalanceInfo` provides information on the tokens the input wallet holds in its balance. */
  tokenBalanceInfo?: Maybe<Array<TokenInfo>>;
  /** `tokenRecommendation` are recommended Tokens the address should purchase based on modeling trading behavior & holdings relative to other addresses (i.e. collaborative filtering model). */
  tokenRecommendation?: Maybe<Array<TokenRecommendation>>;
  /** `userRecommendation` are recommended addresses to follow based on the finding other addresses with similar NFT trading history as the input addresses. */
  userRecommendation?: Maybe<Array<UserRecommendation>>;
};


/** The `Recommendation` type is the base for finding all information that might be interesting/attractive to a given address based on historical transaction history & current balance. */
export type RecommendationTokenBalanceInfoArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The `Recommendation` type is the base for finding all information that might be interesting/attractive to a given address based on historical transaction history & current balance. */
export type RecommendationTokenRecommendationArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


/** The `Recommendation` type is the base for finding all information that might be interesting/attractive to a given address based on historical transaction history & current balance. */
export type RecommendationUserRecommendationArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};

/** The `RefreshAccessTokenInput` type specifies a refresh token. */
export type RefreshAccessTokenInput = {
  /** `refreshToken` the refresh token for refresh accessToken. */
  refreshToken: Scalars['String'];
};

/** The `RefreshAccessTokenResult` type provides an access token for mutation requests that require authentication. */
export type RefreshAccessTokenResult = {
  __typename?: 'RefreshAccessTokenResult';
  /** `accessToken` the access token for mutation requests that require authentication. */
  accessToken: Scalars['String'];
  /** `refreshToken` the refresh token for refresh accessToken. */
  refreshToken: Scalars['String'];
};

export type RegisterEssenceReturnData = {
  __typename?: 'RegisterEssenceReturnData';
  /** `essenceID` the newly created essence ID. */
  essenceID: Scalars['EssenceID'];
  /** `essenceMw` the essence middleware address. */
  essenceMw: Scalars['AddressEVM'];
  /** `essenceTokenURI` the essence tokenURI. */
  essenceTokenURI: Scalars['String'];
  /** `name` the essence name. */
  name: Scalars['String'];
  /** `prepareReturnData` the return data by middleware. */
  prepareReturnData: Scalars['String'];
  /** `profileID` the profile ID that creates the essence. */
  profileID: Scalars['ProfileID'];
  /** `symbol` the essence symbol. */
  symbol: Scalars['String'];
};

/** The `RegisterSigningKeyRequest` input type specifies the params required to register a signing key. */
export type RegisterSigningKeyRequest = {
  /** `address` the user's address. */
  address: Scalars['String'];
  /** `appId` the source of the signing key. Different dapp should use different appId. */
  appId?: InputMaybe<Scalars['String']>;
  /** `message` the generated message to be signed, including the signing key public key information. */
  message: Scalars['String'];
  /** `signature` the signature from signing the `message`. */
  signature: Scalars['String'];
};

/** The `RegisterKeyResponse` type returns `registerSigningKey` request status. */
export type RegisterSigningKeyResponse = {
  __typename?: 'RegisterSigningKeyResponse';
  status: RegisterSigningKeyResponse_Status;
};

export enum RegisterSigningKeyResponse_Status {
  InvalidAddress = 'INVALID_ADDRESS',
  InvalidMessage = 'INVALID_MESSAGE',
  InvalidSignature = 'INVALID_SIGNATURE',
  InvalidSigningKey = 'INVALID_SIGNING_KEY',
  Success = 'SUCCESS'
}

/** The `RelayActionError` type provides error info on a failed relay action. */
export type RelayActionError = {
  __typename?: 'RelayActionError';
  /** `lastKnownTxHash` the last known transaction hash, only presented when the transaction is submitted to the chain. */
  lastKnownTxHash?: Maybe<Scalars['String']>;
  /** `reason` the reason of the failure. */
  reason: Scalars['String'];
};

/** The `RelayActionQueued` type provides the queued time of a relay action, which means the relay action is not submitted to the chain yet. */
export type RelayActionQueued = {
  __typename?: 'RelayActionQueued';
  /** `queuedAt` the queued time of the relay action. */
  queuedAt: Scalars['DateTime'];
  /** `reason` the reason of being in queue. */
  reason: Scalars['String'];
};

/** The `RelayActionStatusResult` type provides relay action status. */
export type RelayActionStatusResult = {
  __typename?: 'RelayActionStatusResult';
  /** `returnData` return data of the relayed transaction, only presented when `txStatus` is `SUCCESS` */
  returnData?: Maybe<RelayReturnDataUnion>;
  /** `txHash` txHash of the relayed transaction, only presented when `txStatus` is `MINTING`, `SUCCESS` or `FAIL` */
  txHash?: Maybe<Scalars['String']>;
  /** `txStatus` status of the relayed transaction. */
  txStatus: TxStatus;
};

export type RelayActionStatusResultUnion = RelayActionError | RelayActionQueued | RelayActionStatusResult;

/** The `RelayInput` input type specifies the Typed Data ID along with the Typed Data signature. */
export type RelayInput = {
  /** `signature` the signature of the Typed Data message. */
  signature?: InputMaybe<Scalars['String']>;
  /** `typedDataID` the Typed Data ID. */
  typedDataID: Scalars['ID'];
};

/** The `RelayResult` type provides a relay receipt used to query the relayed transaction status. */
export type RelayResult = {
  __typename?: 'RelayResult';
  /** `relayActionId` receipt used to query the relayed transaction status. */
  relayActionId: Scalars['ID'];
};

export type RelayReturnDataUnion = CollectEssenceReturnData | CreateProfileReturnData | RegisterEssenceReturnData | SetEssenceDataReturnData | SetMetadataReturnData | SetSubscribeDataReturnData | SubscribeReturnData;

/** The `RelayTransaction` type contains the information about a relayed transaction. */
export type RelayTransaction = Node & {
  __typename?: 'RelayTransaction';
  /** `id` the relayed transaction ID. */
  id: Scalars['ID'];
  /** `txHash` the transaction hash. */
  txHash: Scalars['String'];
  /** `typedData` information about the Typed Data. */
  typedData?: Maybe<TypedData>;
};

export type RevokeSigningKeyRequest = {
  /** `signingKey` the signing key. */
  signingKey: Scalars['String'];
};

export type RevokeSigningKeyResponse = {
  __typename?: 'RevokeSigningKeyResponse';
  status: RevokeSigningKeyResponse_Status;
};

export enum RevokeSigningKeyResponse_Status {
  InvalidAddress = 'INVALID_ADDRESS',
  InvalidSigningKey = 'INVALID_SIGNING_KEY',
  PermissionDenied = 'PERMISSION_DENIED',
  Success = 'SUCCESS'
}

export type SaveTweetInput = {
  link: Scalars['URL'];
};

export type SaveTweetResult = {
  __typename?: 'SaveTweetResult';
  /** `status` the result of link twitter. */
  status: SaveTweetResult_Status;
};

export enum SaveTweetResult_Status {
  /** `ALREADY_SAVED` the user has saved tweet. */
  AlreadySaved = 'ALREADY_SAVED',
  /** `INVALID_TWEET_LINK` tweet link not valid. */
  InvalidTweetLink = 'INVALID_TWEET_LINK',
  /** `NOT_LOGIN` the user is not logged in. */
  NotLogin = 'NOT_LOGIN',
  /** `SUCCESS` save tweet successfully. */
  Success = 'SUCCESS',
  /** `TWEET_ALREADY_USED` tweet is used by another user. */
  TweetAlreadyUsed = 'TWEET_ALREADY_USED',
  /** `TWEET_NOT_FOUND` tweet not found. */
  TweetNotFound = 'TWEET_NOT_FOUND',
  /** `TWEET_NOT_QUALIFIED` tweet not qualified. */
  TweetNotQualified = 'TWEET_NOT_QUALIFIED',
  /** `WRONG_TWITTER` linked twitter not the same as tweet author. */
  WrongTwitter = 'WRONG_TWITTER'
}

export type SavedTweetResult = {
  __typename?: 'SavedTweetResult';
  /** `status` the result of link twitter. */
  status: SavedTweetResult_Status;
};

export enum SavedTweetResult_Status {
  /** `NOT_LOGIN` the user is not logged in. */
  NotLogin = 'NOT_LOGIN',
  /** `NOT_SAVED` the user has not saved tweet. */
  NotSaved = 'NOT_SAVED',
  /** `SUCCESS` query user linked twitter successfully. */
  Success = 'SUCCESS'
}

/** The `Section` type provides the information about secions in the Link3 profile. Every Link3 profile has up to 20 sections in order. */
export type Section = {
  /** `name` the name of the section. */
  name: Scalars['String'];
  /** `type` the type of the section. */
  type: SectionType;
};

export enum SectionType {
  /** `GALAXY_CREDENTIAL` the section of galaxy credentials. */
  GalaxyCredential = 'GALAXY_CREDENTIAL',
  /** `LINK` the section of normal links. */
  Link = 'LINK',
  /** `MENTION` the section of mentioned twitters. */
  Mention = 'MENTION',
  /** `NFT_COLLECTION` the section of nft collections. */
  NftCollection = 'NFT_COLLECTION',
  /** `NFT` the section of NFTs. */
  NftGallery = 'NFT_GALLERY',
  /** `POAP` the section of POAPs. */
  Poap = 'POAP',
  /** `SNAPSHOT` the section of snapshot spaces. */
  Snapshot = 'SNAPSHOT',
  /** `SUPER_LINK` the section of super links. */
  Superlink = 'SUPERLINK',
  /** `W3ST` the section of W3STs. */
  W3StGallery = 'W3ST_GALLERY'
}

export type SetEssenceDataReturnData = {
  __typename?: 'SetEssenceDataReturnData';
  /** `essenceID` the essence ID set essence data to. */
  essenceId: Scalars['EssenceID'];
  /** `mw` the subscribe middleware address */
  mw: Scalars['AddressEVM'];
  /** `prepareReturnData` the return data by middleware */
  prepareReturnData: Scalars['String'];
  /** `profileID` the profile ID set essence data to. */
  profileId: Scalars['ProfileID'];
  /** `tokenURI` the tokenURI of the subscribe NFT */
  tokenURI: Scalars['String'];
};

export type SetMetadataReturnData = {
  __typename?: 'SetMetadataReturnData';
  /** `newMetadata` the metadata set to the profile. */
  newMetadata: Scalars['CID'];
  /** `profileId` the profile ID that set metadata to. */
  profileId: Scalars['ProfileID'];
};

export type SetSubscribeDataReturnData = {
  __typename?: 'SetSubscribeDataReturnData';
  /** `mw` the subscribe middleware address */
  mw: Scalars['AddressEVM'];
  /** `prepareReturnData` the return data by middleware */
  prepareReturnData: Scalars['String'];
  /** `profileID` the profile ID set subscribe data to. */
  profileID: Scalars['ProfileID'];
  /** `tokenURI` the tokenURI of the subscribe NFT */
  tokenURI: Scalars['String'];
};

export type SigningKey = {
  __typename?: 'SigningKey';
  /** `expiredAt` the expiration time of the signing key. */
  expiredAt: Scalars['Timestamp'];
  /** `signingKey` the signing key. */
  signingKey: Scalars['String'];
  /** `source` the source of the signing key. */
  source: Scalars['String'];
};

export type SigningKeyAuth = {
  __typename?: 'SigningKeyAuth';
  address: Scalars['String'];
  message: Scalars['String'];
  signature: Scalars['String'];
};

export enum SigningKeyResponse_Status {
  InvalidAddress = 'INVALID_ADDRESS',
  Success = 'SUCCESS'
}

export type SnapshotSection = Section & {
  __typename?: 'SnapshotSection';
  /** `name` the name of the section. */
  name: Scalars['String'];
  /** `spaceId` take this field if the `type` is `SNAPSHOT`. */
  spaceId: Scalars['String'];
  /** `type` the type of the section. */
  type: SectionType;
};

/** The `Subscribe` type provides information about a subscription. */
export type Subscribe = {
  __typename?: 'Subscribe';
  /** `blockNumber` the block number at which the subscription was created. */
  blockNumber: Scalars['Int'];
  /** `profile` the profile of the Subscriber. */
  profile: Profile;
  /** `wallet` the wallet address of the Subscriber. */
  wallet: Wallet;
};

/** The `SubscribeConnection` type provides a paginated list of `SubscribeEdge` along with the total count of subscriptions. */
export type SubscribeConnection = {
  __typename?: 'SubscribeConnection';
  /** `edges` list of `SubscribeEdge` objects. */
  edges?: Maybe<Array<Maybe<SubscribeEdge>>>;
  /** `pageInfo` contains information about the current page. */
  pageInfo: PageInfo;
  /** `totalCount` the total number of subscriptions. */
  totalCount: Scalars['Int'];
};

/** The `SubscribeEdge` type provides a `Subscribe` node along with its cursor. */
export type SubscribeEdge = {
  __typename?: 'SubscribeEdge';
  /** `cursor` the cursor of the `Subscribe` node. */
  cursor: Scalars['Cursor'];
  /** `node` the node of the `Subscribe` object. */
  node?: Maybe<Subscribe>;
};

/** The `SubscribeMiddleware` input type specifies the middleware to set. */
export type SubscribeMiddleware = {
  /** `customMiddleware` for setting a custom middleware. */
  customMiddleware?: InputMaybe<CustomMwParams>;
  /** `subscribeDisallowed` the subscription to the profile is disallowed. */
  subscribeDisallowed?: InputMaybe<Scalars['Boolean']>;
  /** `subscribeFree` the default module where the subscription to the profile is free. */
  subscribeFree?: InputMaybe<Scalars['Boolean']>;
  /** `subscribeOnlyOnce` the subscription to the profile can happen only once from every other address. */
  subscribeOnlyOnce?: InputMaybe<Scalars['Boolean']>;
  /** `subscribePaid` the subscription to the profile requires the subscriber to pay a fee. */
  subscribePaid?: InputMaybe<SubscribePaidMwParams>;
};

/** The `SubscribeOrder` input type specifies the order in which results are returned. */
export type SubscribeOrder = {
  /** `direction` specifies the order direction. */
  direction: OrderDirection;
};

export type SubscribeReturnData = {
  __typename?: 'SubscribeReturnData';
  /** `postDatas` the post-datas of the subscribe transaction. */
  postDatas: Array<Scalars['String']>;
  /** `preDatas` the pre-datas of the subscribe transaction. */
  preDatas: Array<Scalars['String']>;
  /** `profileIds` the profile IDs that the subscriber subscribes to. */
  profileIds: Array<Scalars['ProfileID']>;
  /** `sender` the subscriber address. */
  sender: Scalars['AddressEVM'];
};

export type SuperLink = {
  __typename?: 'SuperLink';
  /** `description` the description of the superLink. */
  description: Scalars['String'];
  /** `image` the image of the superLink. */
  image: Scalars['URL'];
  /** `link` the url of the superLink. */
  link: Scalars['URL'];
  /** `title` the title of the superLink. */
  title: Scalars['String'];
  /** `type` the type of the superLink. */
  type: SuperLinkType;
};

export type SuperLinkSection = Section & {
  __typename?: 'SuperLinkSection';
  /** `name` the name of the section. */
  name: Scalars['String'];
  /** `superLinks` take this field if the `type` is `SUPERLINK`. */
  superLinks?: Maybe<Array<SuperLink>>;
  /** `type` the type of the section. */
  type: SectionType;
};

export enum SuperLinkType {
  /** `MEDIUM` the medium link. */
  Medium = 'MEDIUM',
  /** `MIRROR` the mirror link. */
  Mirror = 'MIRROR',
  /** `OTHER` the other type link. */
  Other = 'OTHER',
  /** `SUBSTACK` the substack link. */
  Substack = 'SUBSTACK',
  /** `TWEET` the tweet link. */
  Tweet = 'TWEET',
  /** `YOUTUBE` the youtube link. */
  Youtube = 'YOUTUBE'
}

/** The `SystemStatus` type provides information about the last synced block height. */
export type SystemStatus = {
  __typename?: 'SystemStatus';
  /** `blockNumber` the last block number synced. */
  blockNumber: Scalars['Int'];
};

/** The `Token` union type is meant to combine all major Ethereum token interfaces. */
export type Token = Erc20 | Erc721 | Erc1155;

/** The `TokenInfo` type provides additional summary information on token contract, its  community, development team & reach. */
export type TokenInfo = {
  __typename?: 'TokenInfo';
  banner_image_url: Scalars['String'];
  blog: Scalars['String'];
  coingecko_categories?: Maybe<Array<Scalars['String']>>;
  description: Scalars['String'];
  discord: Scalars['String'];
  dune_category: Scalars['String'];
  etherscan_acccount_contractnames?: Maybe<Array<Scalars['String']>>;
  etherscan_labels?: Maybe<Array<Scalars['String']>>;
  etherscan_token_contractnames?: Maybe<Array<Scalars['String']>>;
  facebook_page: Scalars['String'];
  github: Scalars['String'];
  github_organization: Scalars['String'];
  homepage: Scalars['URL'];
  medium: Scalars['String'];
  opensea_status: Scalars['String'];
  subreddit_url: Scalars['String'];
  telegram_channel_url: Scalars['String'];
  token: Token;
  tokenLogo: Scalars['URL'];
  total_supply: Scalars['String'];
  trustwallet_tags?: Maybe<Array<Scalars['String']>>;
  twitter: Scalars['URL'];
};

/** The `TokenRecommendation` type provides additional summary information on token contract, its  community, development team & reach. */
export type TokenRecommendation = {
  __typename?: 'TokenRecommendation';
  /** `distanceScore` is a measure of how close we think this recommendation matches the input. Lower is better. */
  distanceScore: Scalars['Float'];
  /** `rank` is the ranking of this recommendation for the given input. Lower is also better here. */
  rank: Scalars['Int'];
  tokenInfo: TokenInfo;
};

export type TweetNonceResult = {
  __typename?: 'TweetNonceResult';
  /** Nonce for the address, valid only for future saveTweet verification. */
  nonce: Scalars['String'];
  /** `status` the result of tweet nonce. */
  status: TweetNonceResult_Status;
};

export enum TweetNonceResult_Status {
  /** `NOT_LOGIN` the user is not logged in. */
  NotLogin = 'NOT_LOGIN',
  /** `SUCCESS` query user linked twitter successfully. */
  Success = 'SUCCESS'
}

/** The `Twitter` type provides the Twitter account info. */
export type Twitter = {
  __typename?: 'Twitter';
  /** `avatar` the avatar of the twitter. */
  avatar: Scalars['URL'];
  /** `handle` the handle of the twitter. */
  handle: Scalars['String'];
  /** `id` the id of the twitter. */
  id: Scalars['String'];
  /** `name` the display name of the twitter. */
  name: Scalars['String'];
};

export enum TxStatus {
  /** Transaction is submitted to the chain, waiting for confirmation */
  Minting = 'MINTING',
  /** Transaction is confirmed */
  Success = 'SUCCESS'
}

/** The `TypedData` type provides the generated EIP-712 spec Typed Data information. */
export type TypedData = {
  __typename?: 'TypedData';
  /** `chainID` the chain id of the network. */
  chainID: Scalars['ChainID'];
  /** `data` the Typed Data message. */
  data: Scalars['String'];
  /** `id` the Typed Data ID. */
  id: Scalars['ID'];
  /** `nonce` the nonce of the sender. */
  nonce: Scalars['Int'];
  /** `sender` the sender's address. */
  sender: Scalars['AddressEVM'];
};

/** The `TypedDataOptions` input type specifies the Typed Data options required to create a Typed Data message. */
export type TypedDataOptions = {
  /** `overrideNonce` whether to override the nonce. */
  overrideNonce?: InputMaybe<Scalars['Int']>;
};

/** The `UnFollowRequest` input type specifies the params required to unfollow a profile. */
export type UnFollowRequest = {
  /** `address` the user's address. */
  address: Scalars['String'];
  /** `handle` the profile's handle the user wants to unfollow. */
  handle: Scalars['String'];
  /** `message` the operation json string to sign. */
  message: Scalars['String'];
  /** `signature` the signature from signing the `message` json string. */
  signature: Scalars['String'];
  /** `signingKey` the registered signing key. */
  signingKey: Scalars['String'];
};

/** The `UnfollowResponse` type returns `unfollow` request status. */
export type UnFollowResponse = {
  __typename?: 'UnFollowResponse';
  status: UnFollowResponse_Status;
  /** `tsInServer` the server generates the timestamp for cases where the timestamp on the client-side is not reliable. */
  tsInServer?: Maybe<Scalars['Timestamp']>;
};

export enum UnFollowResponse_Status {
  AlreadyDone = 'ALREADY_DONE',
  HandleNotFound = 'HANDLE_NOT_FOUND',
  InvalidMessage = 'INVALID_MESSAGE',
  InvalidParams = 'INVALID_PARAMS',
  InvalidSignature = 'INVALID_SIGNATURE',
  MessageExpired = 'MESSAGE_EXPIRED',
  RateLimited = 'RATE_LIMITED',
  Success = 'SUCCESS'
}

/** The `UserRecommendation` type recommended users to follow based on historical NFT trading/transfer/minting history (based on a Collaborative filtering model). */
export type UserRecommendation = {
  __typename?: 'UserRecommendation';
  userToFollow: Scalars['AddressEVM'];
  /** `userToFollowDistanceScore` is a measure of how close we think this recommendation matches the input. Lower is better. */
  userToFollowDistanceScore: Scalars['Float'];
  /** `userToFollowRank` is the ranking of this recommendation for the given input. */
  userToFollowRank: Scalars['Int'];
  userToFollowReason: Scalars['String'];
};

export type UserStatisticsResult = {
  __typename?: 'UserStatisticsResult';
  status: UserStatisticsResult_Status;
  userSocialRank?: Maybe<Scalars['Int']>;
  userSocialScore: Scalars['Int'];
  userVoted?: Maybe<Array<UserVoted>>;
};

export enum UserStatisticsResult_Status {
  NotLogin = 'NOT_LOGIN',
  Success = 'SUCCESS'
}

export type UserVoteStatusResult = {
  __typename?: 'UserVoteStatusResult';
  canVote: Scalars['Int'];
  status: UserVoteStatusResult_Status;
  voting: Scalars['Int'];
  votingProject?: Maybe<Scalars['String']>;
};

export enum UserVoteStatusResult_Status {
  NotLogin = 'NOT_LOGIN',
  Success = 'SUCCESS'
}

export type UserVoted = {
  __typename?: 'UserVoted';
  TokenID: Scalars['Int'];
  essenceImage: Scalars['String'];
  projectName: Scalars['String'];
  votedCount: Scalars['Int'];
};

/** The `RefreshAccessTokenInput` type specifies a access token to verify. */
export type VerifyAccessTokenInput = {
  /** `accessToken` the access token for mutation requests that require authentication. */
  accessToken: Scalars['String'];
};

/** The `VerifyAccessTokenResult` type retruns if the access token is still valid. */
export type VerifyAccessTokenResult = {
  __typename?: 'VerifyAccessTokenResult';
  /** `isValid` whether the access token is still valid. */
  isValid: Scalars['Boolean'];
};

export type VerifyEssenceMetadataInput = {
  /** `animation_url` URL to a multi-media attachment for the item. */
  animation_url?: InputMaybe<Scalars['URL']>;
  /** `app_id` Id of the application under which the items are being minted. */
  app_id: Scalars['String'];
  /** `attributes` Attributes for the item. */
  attributes?: InputMaybe<Array<AttributeInput>>;
  /** `content` The content associated with the item */
  content?: InputMaybe<Scalars['String']>;
  /** `description` Description of the item. */
  description?: InputMaybe<Scalars['String']>;
  /** `external_url` URL to the item on your site. */
  external_url?: InputMaybe<Scalars['URL']>;
  /** `image` URL to the image of the item. */
  image?: InputMaybe<Scalars['URL']>;
  /** `image_data` SVG image data when the image is not passed. Only use this if you're not including the image parameter. */
  image_data?: InputMaybe<Scalars['String']>;
  /** `issue_date` Creation time of the item as ISO 8601. */
  issue_date?: InputMaybe<Scalars['String']>;
  /** `lang` Language of the content as a BCP47 language tag. */
  lang?: InputMaybe<Scalars['String']>;
  /** `media` Media refers to any image, video, or any other MIME type attached to the content. Limited to max. 10 media objects. */
  media?: InputMaybe<Array<MediaInput>>;
  /** `metadata_id` Unique id for the issued item */
  metadata_id: Scalars['String'];
  /** `name` Name of the item. */
  name?: InputMaybe<Scalars['String']>;
  /** `tags` Field indicating the tags associated with the content. Limited to max. 5 tags. */
  tags?: InputMaybe<Array<Scalars['String']>>;
  /** `version` Version of the metadata schema used for the issued item. Only support `1.0.0` for now. */
  version: Scalars['String'];
};

export type VerifyEssenceMetadataResult = {
  __typename?: 'VerifyEssenceMetadataResult';
  /** `Verified` represents whether the metadata is valid */
  verified: Scalars['Boolean'];
};

export type VoteResponse = {
  __typename?: 'VoteResponse';
  chainId?: Maybe<Scalars['ChainID']>;
  collectId?: Maybe<Scalars['String']>;
  collector?: Maybe<Scalars['AddressEVM']>;
  essenceId?: Maybe<Scalars['EssenceID']>;
  preData?: Maybe<Scalars['String']>;
  profileId?: Maybe<Scalars['ProfileID']>;
  status: VoteResponse_Status;
};

export enum VoteResponse_Status {
  AlreadyVoted = 'ALREADY_VOTED',
  NotEligible = 'NOT_ELIGIBLE',
  NotLogin = 'NOT_LOGIN',
  ProjectNotFound = 'PROJECT_NOT_FOUND',
  Success = 'SUCCESS'
}

export type W3St = {
  __typename?: 'W3ST';
  /** `tokenUri` the tokenUri of the W3ST. */
  tokenUri: Scalars['URL'];
};

export type W3StSection = Section & {
  __typename?: 'W3STSection';
  /** `name` the name of the section. */
  name: Scalars['String'];
  /** `type` the type of the section. */
  type: SectionType;
  /** `w3sts` take this field if the `type` is `W3ST_GALLERY`. */
  w3sts?: Maybe<Array<W3St>>;
};

export type Wallet = Node & {
  __typename?: 'Wallet';
  /** `address` the wallet's address. */
  address: Scalars['AddressEVM'];
  /** `approvedProfiles` provides a paginated list of a profiles that approve this wallet to operate. */
  approvedProfiles: ProfileConnection;
  /** `chainID` the chain id of the network. */
  chainID: Scalars['ChainID'];
  /** `collectedEssences` provides a paginated list of a specified wallet's collected essences. */
  collectedEssences: CollectConnection;
  feed?: Maybe<Array<ErcTransferCard>>;
  /** `id` the wallet's unique identifier. */
  id: Scalars['ID'];
  metadata?: Maybe<WalletMetadata>;
  /** `primaryProfile` provides information about the primary profile of a wallet. */
  primaryProfile?: Maybe<Profile>;
  /** `profiles` provides a paginated list of a specified wallet's profiles. */
  profiles: ProfileConnection;
  recommendation?: Maybe<Recommendation>;
  /** `subscribingCount` the number of subscribings. */
  subscribingCount: Scalars['Int'];
  /** `subscribings` provides a paginated list of a specified wallet's subscribings. */
  subscribings: SubscribeConnection;
};


export type WalletApprovedProfilesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ProfileOrder>;
};


export type WalletCollectedEssencesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  appId?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  metadataId?: InputMaybe<Scalars['String']>;
  orderBy?: InputMaybe<CollectOrder>;
  profileId?: InputMaybe<Scalars['ProfileID']>;
};


export type WalletFeedArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};


export type WalletMetadataArgs = {
  chainID: Scalars['ChainID'];
};


export type WalletProfilesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ProfileOrder>;
};


export type WalletRecommendationArgs = {
  chainID: Scalars['ChainID'];
};


export type WalletSubscribingsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SubscribeOrder>;
};

/** The `WalletConnection` type provides a paginated list of `WalletEdge` along with the total count of profiles. */
export type WalletConnection = {
  __typename?: 'WalletConnection';
  /** `edges` list of `WalletEdge` objects. */
  edges?: Maybe<Array<Maybe<WalletEdge>>>;
  /** `pageInfo` contains information about the current page. */
  pageInfo: PageInfo;
  /** `totalCount` the total number of wallets. */
  totalCount: Scalars['Int'];
};

/** The `WalletEdge` type provides an `Wallet` node along with its cursor. */
export type WalletEdge = {
  __typename?: 'WalletEdge';
  /** `cursor` the cursor of the `Wallet` node. */
  cursor: Scalars['Cursor'];
  /** `node` the node of the `Wallet` object. */
  node?: Maybe<Wallet>;
};

/** The `WalletMetadata` type is the base query for getting information that profiles addresses based on their transaction history. */
export type WalletMetadata = {
  __typename?: 'WalletMetadata';
  /** `labels` are internally generated labels for the input address. */
  labels?: Maybe<Array<Scalars['String']>>;
  /** `projectInteractionStats` provides a list of sorted tx counts with named/known projects */
  projectInteractionStats?: Maybe<Array<ProjectLevelInteraction>>;
};


/** The `WalletMetadata` type is the base query for getting information that profiles addresses based on their transaction history. */
export type WalletMetadataProjectInteractionStatsArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
};

/** The `WalletOrder` input type specifies the order in which results are returned. */
export type WalletOrder = {
  /** `direction` specifies the order direction. */
  direction: OrderDirection;
};

/** The `collectLimitedTimePaidMwParams` input type specifies the `collectLimitedTimePaid` middleware params. */
export type CollectLimitedTimePaidMwParams = {
  /** `currency` the currency contract address. */
  currency: Scalars['ContractAddressEVM'];
  /** `endTimestamp` the end timestamp allowed to collect. */
  endTimestamp: Scalars['Timestamp'];
  /** `price` the price to pay. */
  price: Scalars['String'];
  /** `profileRequired` if the collector needs to hold a ccProfile. */
  profileRequired: Scalars['Boolean'];
  /** `recipient` the recipient wallet address. */
  recipient: Scalars['AddressEVM'];
  /** `startTimestamp` the start timestamp allowed to collect. */
  startTimestamp: Scalars['Timestamp'];
  /** `subscribeRequired` if a subscription is required. */
  subscribeRequired: Scalars['Boolean'];
  /** `totalSupply` the total supply of collects. */
  totalSupply: Scalars['String'];
};

/** The `collectMerkleDropMwParams` input type specifies the `collectMerkleDrop` middleware params. */
export type CollectMerkleDropMwParams = {
  /** `root` the root of the Merkle Tree proofs. Formatted in hex string with 0x prefix. */
  rootHex: Scalars['String'];
};

/** The `collectPaidMwParams` input type specifies the `collectPaid` middleware params. */
export type CollectPaidMwParams = {
  /** `amount` the amount to pay. */
  amount: Scalars['String'];
  /** `currency` the currency contract address. */
  currency: Scalars['ContractAddressEVM'];
  /** `recipient` the recipient wallet address. */
  recipient: Scalars['AddressEVM'];
  /** `subscribeRequired` if a subscription is required. */
  subscribeRequired: Scalars['Boolean'];
  /** `totalSupply` the total supply of collects. */
  totalSupply: Scalars['String'];
};

/** The `collectPermissionMwParams` input type specifies the `collectPermission` middleware params. */
export type CollectPermissionMwParams = {
  /** `signer` the address of the signer. */
  signer: Scalars['AddressEVM'];
};

/** The `collectPermissionPaidMwParams` input type specifies the `collectPermissionPaid` middleware params. */
export type CollectPermissionPaidMwParams = {
  /** `amount` the amount to pay. */
  amount: Scalars['String'];
  /** `currency` the currency contract address. */
  currency: Scalars['ContractAddressEVM'];
  /** `recipient` the recipient wallet address. */
  recipient: Scalars['AddressEVM'];
  /** `signer` the address of the signer. */
  signer: Scalars['AddressEVM'];
  /** `totalSupply` the total supply of collects. */
  totalSupply: Scalars['String'];
};

/** The `customMwParams` input type specifies the custom middleware to set. */
export type CustomMwParams = {
  /** `contractAddress` the middleware contract address. */
  contractAddress: Scalars['ContractAddressEVM'];
  /** `data` the middleware init data, formatted in hex with 0x prefix */
  initData: Scalars['String'];
};

/** The `subscribePaidMwParams` input type specifies the `subscribePaid` middleware params. */
export type SubscribePaidMwParams = {
  /** `amount` the amount to pay. */
  amount: Scalars['String'];
  /** `currency` the currency contract address. */
  currency: Scalars['ContractAddressEVM'];
  /** `nftAddress` the nft contract address. */
  nftAddress: Scalars['ContractAddressEVM'];
  /** `nftRequired` if holding an nft is required. */
  nftRequired: Scalars['Boolean'];
  /** `recipient` the recipient wallet address. */
  recipient: Scalars['AddressEVM'];
};

export type AccountsQueryVariables = Exact<{
  address: Scalars['AddressEVM'];
}>;


export type AccountsQuery = { __typename?: 'Query', address?: { __typename?: 'Address', wallet?: { __typename?: 'Wallet', profiles: { __typename?: 'ProfileConnection', totalCount: number, edges?: Array<{ __typename?: 'ProfileEdge', node?: { __typename?: 'Profile', id: string, profileID: number, handle: string, metadata?: string | null, avatar?: any | null, isPrimary: boolean } | null } | null> | null } } | null } | null };

export type CreateCollectEssenceTypedDataMutationVariables = Exact<{
  input: CreateCollectEssenceTypedDataInput;
}>;


export type CreateCollectEssenceTypedDataMutation = { __typename?: 'Mutation', createCollectEssenceTypedData: { __typename?: 'CreateCollectEssenceTypedDataResult', typedData: { __typename?: 'TypedData', id: string, sender: any, data: string, nonce: number } } };

export type CreateProfileTypedDataMutationVariables = Exact<{
  input: CreateCreateProfileTypedDataInput;
}>;


export type CreateProfileTypedDataMutation = { __typename?: 'Mutation', createCreateProfileTypedData: { __typename?: 'CreateCreateProfileTypedDataResult', typedDataID: string } };

export type CreateRegisterEssenceTypedDataMutationVariables = Exact<{
  input: CreateRegisterEssenceTypedDataInput;
}>;


export type CreateRegisterEssenceTypedDataMutation = { __typename?: 'Mutation', createRegisterEssenceTypedData: { __typename?: 'CreateRegisterEssenceTypedDataResult', typedData: { __typename?: 'TypedData', id: string, sender: any, data: string, nonce: number } } };

export type CreateSubscribeTypedDataMutationVariables = Exact<{
  input: CreateSubscribeTypedDataInput;
}>;


export type CreateSubscribeTypedDataMutation = { __typename?: 'Mutation', createSubscribeTypedData: { __typename?: 'CreateSubscribeTypedDataResult', typedData: { __typename?: 'TypedData', id: string, sender: any, data: string, nonce: number } } };

export type EssencesByAppIdQueryVariables = Exact<{
  appID?: InputMaybe<Scalars['String']>;
  me: Scalars['AddressEVM'];
}>;


export type EssencesByAppIdQuery = { __typename?: 'Query', essencesBy: { __typename?: 'EssenceConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', startCursor?: any | null, endCursor?: any | null, hasNextPage: boolean, hasPreviousPage: boolean }, edges?: Array<{ __typename?: 'EssenceEdge', node?: { __typename?: 'Essence', essenceID: number, tokenURI: any, contractAddress?: any | null, contentID: string, commentCount: number, likeCount: number, createdBy: { __typename?: 'Profile', handle: string, avatar?: any | null, profileID: number }, metadata?: { __typename?: 'EssenceMetadata', tags?: Array<string> | null, issue_date?: string | null, description?: string | null } | null, likedStatus: { __typename?: 'ContentLikeStatus', disliked: boolean, liked: boolean } } | null } | null> | null } };

export type EssencesByFilterQueryVariables = Exact<{
  appID?: InputMaybe<Scalars['String']>;
  me: Scalars['AddressEVM'];
}>;


export type EssencesByFilterQuery = { __typename?: 'Query', essencesBy: { __typename?: 'EssenceConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', startCursor?: any | null, endCursor?: any | null, hasNextPage: boolean, hasPreviousPage: boolean }, edges?: Array<{ __typename?: 'EssenceEdge', node?: { __typename?: 'Essence', essenceID: number, tokenURI: any, contractAddress?: any | null, contentID: string, commentCount: number, likeCount: number, createdBy: { __typename?: 'Profile', handle: string, avatar?: any | null, profileID: number }, metadata?: { __typename?: 'EssenceMetadata', tags?: Array<string> | null, issue_date?: string | null, description?: string | null } | null, likedStatus: { __typename?: 'ContentLikeStatus', disliked: boolean, liked: boolean } } | null } | null> | null } };

export type GetCollectedEssencesByAddressEvmQueryVariables = Exact<{
  address: Scalars['AddressEVM'];
}>;


export type GetCollectedEssencesByAddressEvmQuery = { __typename?: 'Query', address?: { __typename?: 'Address', wallet?: { __typename?: 'Wallet', collectedEssences: { __typename?: 'CollectConnection', edges?: Array<{ __typename?: 'CollectEdge', node?: { __typename?: 'Collect', essence: { __typename?: 'Essence', name: string, tokenURI: any } } | null } | null> | null } } | null } | null };

export type GetEssencesQueryVariables = Exact<{
  appID: Scalars['String'];
  handle: Scalars['String'];
}>;


export type GetEssencesQuery = { __typename?: 'Query', profileByHandle?: { __typename?: 'Profile', essences: { __typename?: 'EssenceConnection', totalCount: number, edges?: Array<{ __typename?: 'EssenceEdge', node?: { __typename?: 'Essence', name: string, tokenURI: any } | null } | null> | null } } | null };

export type PrimaryProfileQueryVariables = Exact<{
  address: Scalars['AddressEVM'];
}>;


export type PrimaryProfileQuery = { __typename?: 'Query', address?: { __typename?: 'Address', wallet?: { __typename?: 'Wallet', primaryProfile?: { __typename?: 'Profile', id: string, profileID: number, handle: string, metadata?: string | null, avatar?: any | null, isPrimary: boolean } | null } | null } | null };

export type PrimaryProfileEssencesQueryVariables = Exact<{
  address: Scalars['AddressEVM'];
}>;


export type PrimaryProfileEssencesQuery = { __typename?: 'Query', address?: { __typename?: 'Address', wallet?: { __typename?: 'Wallet', primaryProfile?: { __typename?: 'Profile', essences: { __typename?: 'EssenceConnection', totalCount: number, edges?: Array<{ __typename?: 'EssenceEdge', node?: { __typename?: 'Essence', essenceID: number, tokenURI: any, isCollectedByMe: boolean, createdBy: { __typename?: 'Profile', handle: string, metadata?: string | null, avatar?: any | null, profileID: number } } | null } | null> | null } } | null } | null } | null };

export type GetProfileByHandleQueryVariables = Exact<{
  handle: Scalars['String'];
}>;


export type GetProfileByHandleQuery = { __typename?: 'Query', profileByHandle?: { __typename?: 'Profile', isPrimary: boolean, profileID: number, metadataInfo?: { __typename?: 'MetadataDetail', avatar: string, bio: string } | null, owner: { __typename?: 'Wallet', address: any } } | null };

export type RelayMutationVariables = Exact<{
  input: RelayInput;
}>;


export type RelayMutation = { __typename?: 'Mutation', relay: { __typename?: 'RelayResult', relayActionId: string } };

export type RelayActionStatusQueryVariables = Exact<{
  relayActionId: Scalars['ID'];
}>;


export type RelayActionStatusQuery = { __typename?: 'Query', relayActionStatus?: { __typename?: 'RelayActionError', reason: string, lastKnownTxHash?: string | null } | { __typename?: 'RelayActionQueued', queuedAt: any } | { __typename?: 'RelayActionStatusResult', txHash?: string | null, txStatus: TxStatus } | null };

export type VerifyMetaDataQueryVariables = Exact<{
  metaData: VerifyEssenceMetadataInput;
}>;


export type VerifyMetaDataQuery = { __typename?: 'Query', verifyEssenceMetadata: { __typename?: 'VerifyEssenceMetadataResult', verified: boolean } };

export type VerifyHandleQueryVariables = Exact<{
  handle: Scalars['String'];
}>;


export type VerifyHandleQuery = { __typename?: 'Query', profileHandleEligibility: { __typename?: 'ProfileHandleEligibility', status: ProfileHandleEligibility_Status } };

export type LoginGetMessageMutationVariables = Exact<{
  input: LoginGetMessageInput;
}>;


export type LoginGetMessageMutation = { __typename?: 'Mutation', loginGetMessage: { __typename?: 'LoginGetMessageResult', message: string } };

export type LoginVerifyMutationVariables = Exact<{
  domain: Scalars['String'];
  address: Scalars['AddressEVM'];
  signature: Scalars['String'];
}>;


export type LoginVerifyMutation = { __typename?: 'Mutation', loginVerify: { __typename?: 'LoginVerifyResult', accessToken: string } };


export const AccountsDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"Accounts"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"address"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"AddressEVM"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"address"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"address"},"value":{"kind":"Variable","name":{"kind":"Name","value":"address"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"wallet"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"profiles"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"totalCount"}},{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"profileID"}},{"kind":"Field","name":{"kind":"Name","value":"handle"}},{"kind":"Field","name":{"kind":"Name","value":"metadata"}},{"kind":"Field","name":{"kind":"Name","value":"avatar"}},{"kind":"Field","name":{"kind":"Name","value":"isPrimary"}}]}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<AccountsQuery, AccountsQueryVariables>;
export const CreateCollectEssenceTypedDataDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"CreateCollectEssenceTypedData"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"input"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"CreateCollectEssenceTypedDataInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"createCollectEssenceTypedData"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"input"},"value":{"kind":"Variable","name":{"kind":"Name","value":"input"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"typedData"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"sender"}},{"kind":"Field","name":{"kind":"Name","value":"data"}},{"kind":"Field","name":{"kind":"Name","value":"nonce"}}]}}]}}]}}]} as unknown as DocumentNode<CreateCollectEssenceTypedDataMutation, CreateCollectEssenceTypedDataMutationVariables>;
export const CreateProfileTypedDataDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"CreateProfileTypedData"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"input"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"CreateCreateProfileTypedDataInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"createCreateProfileTypedData"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"input"},"value":{"kind":"Variable","name":{"kind":"Name","value":"input"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"typedDataID"}}]}}]}}]} as unknown as DocumentNode<CreateProfileTypedDataMutation, CreateProfileTypedDataMutationVariables>;
export const CreateRegisterEssenceTypedDataDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"CreateRegisterEssenceTypedData"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"input"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"CreateRegisterEssenceTypedDataInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"createRegisterEssenceTypedData"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"input"},"value":{"kind":"Variable","name":{"kind":"Name","value":"input"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"typedData"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"sender"}},{"kind":"Field","name":{"kind":"Name","value":"data"}},{"kind":"Field","name":{"kind":"Name","value":"nonce"}}]}}]}}]}}]} as unknown as DocumentNode<CreateRegisterEssenceTypedDataMutation, CreateRegisterEssenceTypedDataMutationVariables>;
export const CreateSubscribeTypedDataDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"CreateSubscribeTypedData"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"input"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"CreateSubscribeTypedDataInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"createSubscribeTypedData"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"input"},"value":{"kind":"Variable","name":{"kind":"Name","value":"input"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"typedData"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"sender"}},{"kind":"Field","name":{"kind":"Name","value":"data"}},{"kind":"Field","name":{"kind":"Name","value":"nonce"}}]}}]}}]}}]} as unknown as DocumentNode<CreateSubscribeTypedDataMutation, CreateSubscribeTypedDataMutationVariables>;
export const EssencesByAppIdDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"essencesByAppId"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"appID"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"me"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"AddressEVM"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"essencesBy"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"appID"},"value":{"kind":"Variable","name":{"kind":"Name","value":"appID"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"totalCount"}},{"kind":"Field","name":{"kind":"Name","value":"pageInfo"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"startCursor"}},{"kind":"Field","name":{"kind":"Name","value":"endCursor"}},{"kind":"Field","name":{"kind":"Name","value":"hasNextPage"}},{"kind":"Field","name":{"kind":"Name","value":"hasPreviousPage"}}]}},{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"essenceID"}},{"kind":"Field","name":{"kind":"Name","value":"tokenURI"}},{"kind":"Field","name":{"kind":"Name","value":"contractAddress"}},{"kind":"Field","name":{"kind":"Name","value":"createdBy"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"handle"}},{"kind":"Field","name":{"kind":"Name","value":"avatar"}},{"kind":"Field","name":{"kind":"Name","value":"profileID"}}]}},{"kind":"Field","name":{"kind":"Name","value":"metadata"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"tags"}},{"kind":"Field","name":{"kind":"Name","value":"issue_date"}},{"kind":"Field","name":{"kind":"Name","value":"description"}}]}},{"kind":"Field","name":{"kind":"Name","value":"contentID"}},{"kind":"Field","name":{"kind":"Name","value":"commentCount"}},{"kind":"Field","name":{"kind":"Name","value":"likeCount"}},{"kind":"Field","name":{"kind":"Name","value":"likedStatus"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"me"},"value":{"kind":"Variable","name":{"kind":"Name","value":"me"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"disliked"}},{"kind":"Field","name":{"kind":"Name","value":"liked"}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<EssencesByAppIdQuery, EssencesByAppIdQueryVariables>;
export const EssencesByFilterDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"essencesByFilter"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"appID"}},"type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"me"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"AddressEVM"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"essencesBy"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"appID"},"value":{"kind":"Variable","name":{"kind":"Name","value":"appID"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"totalCount"}},{"kind":"Field","name":{"kind":"Name","value":"pageInfo"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"startCursor"}},{"kind":"Field","name":{"kind":"Name","value":"endCursor"}},{"kind":"Field","name":{"kind":"Name","value":"hasNextPage"}},{"kind":"Field","name":{"kind":"Name","value":"hasPreviousPage"}}]}},{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"essenceID"}},{"kind":"Field","name":{"kind":"Name","value":"tokenURI"}},{"kind":"Field","name":{"kind":"Name","value":"contractAddress"}},{"kind":"Field","name":{"kind":"Name","value":"createdBy"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"handle"}},{"kind":"Field","name":{"kind":"Name","value":"avatar"}},{"kind":"Field","name":{"kind":"Name","value":"profileID"}}]}},{"kind":"Field","name":{"kind":"Name","value":"metadata"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"tags"}},{"kind":"Field","name":{"kind":"Name","value":"issue_date"}},{"kind":"Field","name":{"kind":"Name","value":"description"}}]}},{"kind":"Field","name":{"kind":"Name","value":"contentID"}},{"kind":"Field","name":{"kind":"Name","value":"commentCount"}},{"kind":"Field","name":{"kind":"Name","value":"likeCount"}},{"kind":"Field","name":{"kind":"Name","value":"likedStatus"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"me"},"value":{"kind":"Variable","name":{"kind":"Name","value":"me"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"disliked"}},{"kind":"Field","name":{"kind":"Name","value":"liked"}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<EssencesByFilterQuery, EssencesByFilterQueryVariables>;
export const GetCollectedEssencesByAddressEvmDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"getCollectedEssencesByAddressEVM"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"address"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"AddressEVM"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"address"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"address"},"value":{"kind":"Variable","name":{"kind":"Name","value":"address"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"wallet"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"collectedEssences"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"first"},"value":{"kind":"IntValue","value":"4"}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"essence"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"tokenURI"}}]}}]}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<GetCollectedEssencesByAddressEvmQuery, GetCollectedEssencesByAddressEvmQueryVariables>;
export const GetEssencesDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"getEssences"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"appID"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"handle"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"profileByHandle"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"handle"},"value":{"kind":"Variable","name":{"kind":"Name","value":"handle"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"essences"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"appID"},"value":{"kind":"Variable","name":{"kind":"Name","value":"appID"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"totalCount"}},{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"tokenURI"}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<GetEssencesQuery, GetEssencesQueryVariables>;
export const PrimaryProfileDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"PrimaryProfile"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"address"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"AddressEVM"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"address"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"address"},"value":{"kind":"Variable","name":{"kind":"Name","value":"address"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"wallet"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"primaryProfile"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"profileID"}},{"kind":"Field","name":{"kind":"Name","value":"handle"}},{"kind":"Field","name":{"kind":"Name","value":"metadata"}},{"kind":"Field","name":{"kind":"Name","value":"avatar"}},{"kind":"Field","name":{"kind":"Name","value":"isPrimary"}}]}}]}}]}}]}}]} as unknown as DocumentNode<PrimaryProfileQuery, PrimaryProfileQueryVariables>;
export const PrimaryProfileEssencesDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"PrimaryProfileEssences"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"address"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"AddressEVM"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"address"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"address"},"value":{"kind":"Variable","name":{"kind":"Name","value":"address"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"wallet"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"primaryProfile"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"essences"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"totalCount"}},{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"essenceID"}},{"kind":"Field","name":{"kind":"Name","value":"tokenURI"}},{"kind":"Field","name":{"kind":"Name","value":"createdBy"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"handle"}},{"kind":"Field","name":{"kind":"Name","value":"metadata"}},{"kind":"Field","name":{"kind":"Name","value":"avatar"}},{"kind":"Field","name":{"kind":"Name","value":"profileID"}}]}},{"kind":"Field","name":{"kind":"Name","value":"isCollectedByMe"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"me"},"value":{"kind":"Variable","name":{"kind":"Name","value":"address"}}}]}]}}]}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<PrimaryProfileEssencesQuery, PrimaryProfileEssencesQueryVariables>;
export const GetProfileByHandleDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"getProfileByHandle"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"handle"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"profileByHandle"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"handle"},"value":{"kind":"Variable","name":{"kind":"Name","value":"handle"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"metadataInfo"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"avatar"}},{"kind":"Field","name":{"kind":"Name","value":"bio"}}]}},{"kind":"Field","name":{"kind":"Name","value":"owner"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"address"}}]}},{"kind":"Field","name":{"kind":"Name","value":"isPrimary"}},{"kind":"Field","name":{"kind":"Name","value":"profileID"}}]}}]}}]} as unknown as DocumentNode<GetProfileByHandleQuery, GetProfileByHandleQueryVariables>;
export const RelayDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"Relay"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"input"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"RelayInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"relay"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"input"},"value":{"kind":"Variable","name":{"kind":"Name","value":"input"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"relayActionId"}}]}}]}}]} as unknown as DocumentNode<RelayMutation, RelayMutationVariables>;
export const RelayActionStatusDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"RelayActionStatus"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"relayActionId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"ID"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"relayActionStatus"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"relayActionId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"relayActionId"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"RelayActionStatusResult"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"txHash"}},{"kind":"Field","name":{"kind":"Name","value":"txStatus"}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"RelayActionError"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"reason"}},{"kind":"Field","name":{"kind":"Name","value":"lastKnownTxHash"}}]}},{"kind":"InlineFragment","typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"RelayActionQueued"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"queuedAt"}}]}}]}}]}}]} as unknown as DocumentNode<RelayActionStatusQuery, RelayActionStatusQueryVariables>;
export const VerifyMetaDataDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"VerifyMetaData"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"metaData"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"VerifyEssenceMetadataInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"verifyEssenceMetadata"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"input"},"value":{"kind":"Variable","name":{"kind":"Name","value":"metaData"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"verified"}}]}}]}}]} as unknown as DocumentNode<VerifyMetaDataQuery, VerifyMetaDataQueryVariables>;
export const VerifyHandleDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"VerifyHandle"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"handle"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"profileHandleEligibility"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"handle"},"value":{"kind":"Variable","name":{"kind":"Name","value":"handle"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"status"}}]}}]}}]} as unknown as DocumentNode<VerifyHandleQuery, VerifyHandleQueryVariables>;
export const LoginGetMessageDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"LoginGetMessage"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"input"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"LoginGetMessageInput"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"loginGetMessage"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"input"},"value":{"kind":"Variable","name":{"kind":"Name","value":"input"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"message"}}]}}]}}]} as unknown as DocumentNode<LoginGetMessageMutation, LoginGetMessageMutationVariables>;
export const LoginVerifyDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"mutation","name":{"kind":"Name","value":"loginVerify"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"domain"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"address"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"AddressEVM"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"signature"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"loginVerify"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"input"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"domain"},"value":{"kind":"Variable","name":{"kind":"Name","value":"domain"}}},{"kind":"ObjectField","name":{"kind":"Name","value":"address"},"value":{"kind":"Variable","name":{"kind":"Name","value":"address"}}},{"kind":"ObjectField","name":{"kind":"Name","value":"signature"},"value":{"kind":"Variable","name":{"kind":"Name","value":"signature"}}}]}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"accessToken"}}]}}]}}]} as unknown as DocumentNode<LoginVerifyMutation, LoginVerifyMutationVariables>;